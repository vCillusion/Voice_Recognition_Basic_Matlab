<?xml version="1.0" encoding="utf-8"?>
<mscript xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">
   <version>7.5</version>
   <date>2012-04-20</date>
   <cell>
      <count>1</count>
      <steptitle>Project: Voice Recognition and Identification system</steptitle>
      <text>
         <p>By  Mahima Garg, Omar Razi, Supriya Phutela, Vaibhav Kapoor, Varun Chopra</p>
      </text>
      <mcode>%--------------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve"><mwsh:comments xml:space="preserve">%--------------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>1</mcode-count>
   </cell>
   <cell>
      <count>2</count>
      <steptitle>Main Function Voice Recognition</steptitle>
      <mcode>function []=voicerecognition()
% For clear screen
clc;
% Ronaldo is a variable used to directly set the minimum distance for
% speech recognition.
ronaldo=10;
% Drogba is a variable used to directly set the maximum number of
% users stored in database
drogba=8;
% st, st1, st2, st3,  will be used for filenames related purposes reducing
% code redundancy.
char st; char st1; char st2; char st3;
disp('Project: Voice Recognition and Identification system');
disp('By  Mahima Garg &amp; Omar Razi &amp; Supriya Phutela &amp; Vaibhav Kapoor &amp; Varun Chopra ');
disp(' ');
pause(0.5);
disp('LOADING ');
pause(1);
disp('... ');
pause(1);
disp('... ');
pause(1);
disp('... ');
pause(1);
disp('... ');
msgbox('We have tried to make this project as user friendly as possible. We Hope you Appreciate and Enjoy !!!','Voice Recognition and Identification System');

% Preallocating array
str = {8}; fstr = {8}; nbtr = {8};
ste = {8}; fste = {8}; nbte = {8};
ctr = {8}; dtr={8};
cte = {8}; dte={8};
data = {drogba,4};
code = {8};

for i = 1:8

    % Read audio data from train folder for performing operations
    st=strcat('train\s',num2str(i),'.wav');
    [s1 fs1 nb1]=wavread(st);
    str{i} = s1; fstr{i} = fs1; nbtr{i} = nb1;

    % Read audio data from test folder for performing operations
    st = strcat('test\s',num2str(i),'.wav');
    [st1 fst1 nbt1] = wavread(st);
    ste{i} = st1; fste{i} = fst1; nbte{i} = nbt1;

    % Compute MFCC of the audio data to be used in Speech Processing for Train
    % Folder
    ctr{i} = mfcc(str{i},fstr{i});

    % Compute MFCC of the audio data to be used in Speech Processing for Test
    % Folder
    cte{i} = mfcc(ste{i},fste{i});

    % Compute Vector Quantization of the audio data to be used in Speech
    % Processing for Train Folder
    dtr{i} = vqlbg(ctr{i},16);

    % Compute Vector Quantization of the audio data to be used in Speech
    % Processing for Test Folder
    dte{i} = vqlbg(cte{i},16);
end

% For making Choice
ch=0;
poss=11;
while ch~=poss

    ch=menu('Speaker Recognition System','1: Human speaker recognition',...
        '2: Technical data of samples',...
        '3: Power Spectrum','4: Power Spectrum with different M and N',...
        '5: Mel-Spaced Filter Bank',...
        '6: Spectrum before and after Mel-Frequency wrapping',...
        '7: 2D plot of acoustic vectors',...
        '8: Plot of VQ codewords','9: Recognition rate of the computer',...
        '10: Test with other speech files','11: Exit');
    disp('                                                                  ');
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve"><mwsh:keywords xml:space="preserve">function</mwsh:keywords> []=voicerecognition()
<mwsh:comments xml:space="preserve">% For clear screen</mwsh:comments>
clc;
<mwsh:comments xml:space="preserve">% Ronaldo is a variable used to directly set the minimum distance for</mwsh:comments>
<mwsh:comments xml:space="preserve">% speech recognition.</mwsh:comments>
ronaldo=10;
<mwsh:comments xml:space="preserve">% Drogba is a variable used to directly set the maximum number of</mwsh:comments>
<mwsh:comments xml:space="preserve">% users stored in database</mwsh:comments>
drogba=8;
<mwsh:comments xml:space="preserve">% st, st1, st2, st3,  will be used for filenames related purposes reducing</mwsh:comments>
<mwsh:comments xml:space="preserve">% code redundancy.</mwsh:comments>
char <mwsh:strings xml:space="preserve">st</mwsh:strings>; char <mwsh:strings xml:space="preserve">st1</mwsh:strings>; char <mwsh:strings xml:space="preserve">st2</mwsh:strings>; char <mwsh:strings xml:space="preserve">st3</mwsh:strings>;
disp(<mwsh:strings xml:space="preserve">'Project: Voice Recognition and Identification system'</mwsh:strings>);
disp(<mwsh:strings xml:space="preserve">'By  Mahima Garg &amp; Omar Razi &amp; Supriya Phutela &amp; Vaibhav Kapoor &amp; Varun Chopra '</mwsh:strings>);
disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
pause(0.5);
disp(<mwsh:strings xml:space="preserve">'LOADING '</mwsh:strings>);
pause(1);
disp(<mwsh:strings xml:space="preserve">'... '</mwsh:strings>);
pause(1);
disp(<mwsh:strings xml:space="preserve">'... '</mwsh:strings>);
pause(1);
disp(<mwsh:strings xml:space="preserve">'... '</mwsh:strings>);
pause(1);
disp(<mwsh:strings xml:space="preserve">'... '</mwsh:strings>);
msgbox(<mwsh:strings xml:space="preserve">'We have tried to make this project as user friendly as possible. We Hope you Appreciate and Enjoy !!!'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Voice Recognition and Identification System'</mwsh:strings>);

<mwsh:comments xml:space="preserve">% Preallocating array</mwsh:comments>
str = {8}; fstr = {8}; nbtr = {8};
ste = {8}; fste = {8}; nbte = {8};
ctr = {8}; dtr={8};
cte = {8}; dte={8};
data = {drogba,4};
code = {8};

<mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:8

    <mwsh:comments xml:space="preserve">% Read audio data from train folder for performing operations</mwsh:comments>
    st=strcat(<mwsh:strings xml:space="preserve">'train\s'</mwsh:strings>,num2str(i),<mwsh:strings xml:space="preserve">'.wav'</mwsh:strings>);
    [s1 fs1 nb1]=wavread(st);
    str{i} = s1; fstr{i} = fs1; nbtr{i} = nb1;

    <mwsh:comments xml:space="preserve">% Read audio data from test folder for performing operations</mwsh:comments>
    st = strcat(<mwsh:strings xml:space="preserve">'test\s'</mwsh:strings>,num2str(i),<mwsh:strings xml:space="preserve">'.wav'</mwsh:strings>);
    [st1 fst1 nbt1] = wavread(st);
    ste{i} = st1; fste{i} = fst1; nbte{i} = nbt1;

    <mwsh:comments xml:space="preserve">% Compute MFCC of the audio data to be used in Speech Processing for Train</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Folder</mwsh:comments>
    ctr{i} = mfcc(str{i},fstr{i});

    <mwsh:comments xml:space="preserve">% Compute MFCC of the audio data to be used in Speech Processing for Test</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Folder</mwsh:comments>
    cte{i} = mfcc(ste{i},fste{i});

    <mwsh:comments xml:space="preserve">% Compute Vector Quantization of the audio data to be used in Speech</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Processing for Train Folder</mwsh:comments>
    dtr{i} = vqlbg(ctr{i},16);

    <mwsh:comments xml:space="preserve">% Compute Vector Quantization of the audio data to be used in Speech</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Processing for Test Folder</mwsh:comments>
    dte{i} = vqlbg(cte{i},16);
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>

<mwsh:comments xml:space="preserve">% For making Choice</mwsh:comments>
ch=0;
poss=11;
<mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch~=poss

    ch=menu(<mwsh:strings xml:space="preserve">'Speaker Recognition System'</mwsh:strings>,<mwsh:strings xml:space="preserve">'1: Human speaker recognition'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'2: Technical data of samples'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'3: Power Spectrum'</mwsh:strings>,<mwsh:strings xml:space="preserve">'4: Power Spectrum with different M and N'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'5: Mel-Spaced Filter Bank'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'6: Spectrum before and after Mel-Frequency wrapping'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'7: 2D plot of acoustic vectors'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'8: Plot of VQ codewords'</mwsh:strings>,<mwsh:strings xml:space="preserve">'9: Recognition rate of the computer'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
        <mwsh:strings xml:space="preserve">'10: Test with other speech files'</mwsh:strings>,<mwsh:strings xml:space="preserve">'11: Exit'</mwsh:strings>);
    disp(<mwsh:strings xml:space="preserve">'                                                                  '</mwsh:strings>);
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>2</mcode-count>
   </cell>
   <cell>
      <count>3</count>
      <steptitle>1: Human speaker recognition</steptitle>
      <mcode>    % Play each sound file in the TRAIN folder. Can you distinguish the voices
    % of those eight speakers? Now play each sound in the TEST folder in a
    % random order without looking at the file name (pretending that you do not
    % know the speaker) and try to identify the speaker using your knowledge of
    % their voices that you just learned from the TRAIN folder. This is exactly
    % what the computer will do in our system.
    % What is your (human performance) recognition rate ?
    % Record this result so that it can be used later to be compared with the
    % computer's performance of our system. Both of us seem to be unable to
    % recognise random people just by listening at their voice. Our success
    % rates for the provided samples were 1 person out of 8 each.
    %
    % However, for the samples we used in question 10, we were easily able to
    % recognise each speaker. This is probably because we knew all the persons.
    % We also realized that we did not identify speakers by the frequencies
    % they use to talk, but rather by other characteristics, like accent,
    % speed, etc.

    if ch==1
        disp('&gt;  1: Human speaker recognition');
        disp('Play each sound file in the TRAIN folder.');
        disp('Can you distinguish the voices of those eight speakers?');
        disp('Now play each sound in the TEST folder in a random order without looking at the file name ');
        disp('and try to identify the speaker using your knowledge of their voices that you have just heard,');
        disp('from the TRAIN folder. This is exactly what the computer will do in our system.');
        disp('                                                                                                  ');
        disp('                                                                                                   ');
        disp('All of us seem to be unable to recognise random people just by listening to their voice. ');
        disp('We also realize that we do not identify speakers by the frequencies with which they use to talk,  ');
        disp('but rather by other characteristics, like accent, speed, etc.');
        pause(1);

        ch2=0;
        while ch2~=4
            ch2=menu('Select Folder','Train','Test','User','Exit');

            if ch2==1

                ch3=0;
                while ch3~=9
                    ch3=menu('Train :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        p=audioplayer(str{ch3},fstr{ch3},nbtr{ch3});
                        play(p);
                    end
                end
            end

            if ch2==2

                ch3=0;
                while ch3~=9
                    ch3=menu('Test :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        p=audioplayer(ste{ch3},fste{ch3},nbte{ch3});
                        play(p);
                    end
                end
                close all;
            end

            if ch2==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs nb]=wavread(st);
                                    p=audioplayer(s,fs,nb);
                                    play(p);

                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                        close all;
                    end

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Play each sound file in the TRAIN folder. Can you distinguish the voices</mwsh:comments>
    <mwsh:comments xml:space="preserve">% of those eight speakers? Now play each sound in the TEST folder in a</mwsh:comments>
    <mwsh:comments xml:space="preserve">% random order without looking at the file name (pretending that you do not</mwsh:comments>
    <mwsh:comments xml:space="preserve">% know the speaker) and try to identify the speaker using your knowledge of</mwsh:comments>
    <mwsh:comments xml:space="preserve">% their voices that you just learned from the TRAIN folder. This is exactly</mwsh:comments>
    <mwsh:comments xml:space="preserve">% what the computer will do in our system.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% What is your (human performance) recognition rate ?</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Record this result so that it can be used later to be compared with the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% computer's performance of our system. Both of us seem to be unable to</mwsh:comments>
    <mwsh:comments xml:space="preserve">% recognise random people just by listening at their voice. Our success</mwsh:comments>
    <mwsh:comments xml:space="preserve">% rates for the provided samples were 1 person out of 8 each.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% However, for the samples we used in question 10, we were easily able to</mwsh:comments>
    <mwsh:comments xml:space="preserve">% recognise each speaker. This is probably because we knew all the persons.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% We also realized that we did not identify speakers by the frequencies</mwsh:comments>
    <mwsh:comments xml:space="preserve">% they use to talk, but rather by other characteristics, like accent,</mwsh:comments>
    <mwsh:comments xml:space="preserve">% speed, etc.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==1
        disp(<mwsh:strings xml:space="preserve">'&gt;  1: Human speaker recognition'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Play each sound file in the TRAIN folder.'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Can you distinguish the voices of those eight speakers?'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Now play each sound in the TEST folder in a random order without looking at the file name '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'and try to identify the speaker using your knowledge of their voices that you have just heard,'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'from the TRAIN folder. This is exactly what the computer will do in our system.'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'                                                                                                  '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'                                                                                                   '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'All of us seem to be unable to recognise random people just by listening to their voice. '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'We also realize that we do not identify speakers by the frequencies with which they use to talk,  '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'but rather by other characteristics, like accent, speed, etc.'</mwsh:strings>);
        pause(1);

        ch2=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch2~=4
            ch2=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch2==1

                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=9
                    ch3=menu(<mwsh:strings xml:space="preserve">'Train :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        p=audioplayer(str{ch3},fstr{ch3},nbtr{ch3});
                        play(p);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch2==2

                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=9
                    ch3=menu(<mwsh:strings xml:space="preserve">'Test :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        p=audioplayer(ste{ch3},fste{ch3},nbte{ch3});
                        play(p);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch2==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs nb]=wavread(st);
                                    p=audioplayer(s,fs,nb);
                                    play(p);

                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>3</mcode-count>
   </cell>
   <cell>
      <count>4</count>
      <steptitle>2: Technical data of samples</steptitle>
      <mcode>    % Read a sound file into Matlab. Check it by playing the sound file in
    % Matlab using the function: sound. What is the sampling rate? What is the
    % highest frequency that the recorded sound can capture with fidelity? With
    % that sampling rate, how many msecs of actual speech are contained in a
    % block of 256 samples?
    %
    % Plot the signal to view it in the time domain. It should be obvious that
    % the raw data in the time domain has a great amount of data and for this
    % reason it is difficult to analyse the voice characteristic. So the
    % purpose of this step (speech feature extraction) should be clear now!
    %
    % Intermediate steps that follows:
    %
    % Frames blocking phase
    % To obtain a matrix M containing all the frames, we used the following script:
    % That way we obtain the 256 x 129 matrix M.
    %
    % Windowing phase
    % We create the Hamming matrix and transform the matrix M into the new
    % matrix M2, where the column vectors of M2 are the original frame vectors
    % transformed by the Hamming filter.
    %
    % FFT Phase
    % We create a new matrix M3 where the column vectors are the FFTs of the
    % column vectors of M2.

    if ch==2
        disp('&gt; 2: Technical data of samples');

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss2=9;
                ch2=0;
                while ch2~=poss2
                    ch2=menu('Technical data of samples for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch2~=9
                        t = 0:1/fstr{ch2}:(length(str{ch2}) - 1)/fstr{ch2};
                        plot(t, str{ch2}), axis([0, (length(str{ch2}) - 1)/fstr{ch2} -0.4 0.5]);
                        st=sprintf('Plot of signal s%d.wav',ch2);
                        title(st);
                        xlabel('Time [s]');
                        ylabel('Amplitude (normalized)')
                    end
                end
                close all
            end

            if ch23==2
                poss2=9;
                ch2=0;
                while ch2~=poss2
                    ch2=menu('Technical data of samples for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch2~=9
                        t = 0:1/fste{ch2}:(length(ste{ch2}) - 1)/fste{ch2};
                        plot(t, ste{ch2}), axis([0, (length(ste{ch2}) - 1)/fste{ch2} -0.4 0.5]);
                        st=sprintf('Plot of signal s%d.wav',ch2);
                        title(st);
                        xlabel('Time [s]');
                        ylabel('Amplitude (normalized)')
                    end
                end
                close all
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    t = 0:1/fs:(length(s) - 1)/fs;
                                    plot(t, s), axis([0, (length(s) - 1)/fs -0.4 0.5]);
                                    st=sprintf('Plot of signal %s',st);
                                    title(st);
                                    xlabel('Time [s]');
                                    ylabel('Amplitude (normalized)')

                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end

                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Read a sound file into Matlab. Check it by playing the sound file in</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Matlab using the function: sound. What is the sampling rate? What is the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% highest frequency that the recorded sound can capture with fidelity? With</mwsh:comments>
    <mwsh:comments xml:space="preserve">% that sampling rate, how many msecs of actual speech are contained in a</mwsh:comments>
    <mwsh:comments xml:space="preserve">% block of 256 samples?</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Plot the signal to view it in the time domain. It should be obvious that</mwsh:comments>
    <mwsh:comments xml:space="preserve">% the raw data in the time domain has a great amount of data and for this</mwsh:comments>
    <mwsh:comments xml:space="preserve">% reason it is difficult to analyse the voice characteristic. So the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% purpose of this step (speech feature extraction) should be clear now!</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Intermediate steps that follows:</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Frames blocking phase</mwsh:comments>
    <mwsh:comments xml:space="preserve">% To obtain a matrix M containing all the frames, we used the following script:</mwsh:comments>
    <mwsh:comments xml:space="preserve">% That way we obtain the 256 x 129 matrix M.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Windowing phase</mwsh:comments>
    <mwsh:comments xml:space="preserve">% We create the Hamming matrix and transform the matrix M into the new</mwsh:comments>
    <mwsh:comments xml:space="preserve">% matrix M2, where the column vectors of M2 are the original frame vectors</mwsh:comments>
    <mwsh:comments xml:space="preserve">% transformed by the Hamming filter.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% FFT Phase</mwsh:comments>
    <mwsh:comments xml:space="preserve">% We create a new matrix M3 where the column vectors are the FFTs of the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% column vectors of M2.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==2
        disp(<mwsh:strings xml:space="preserve">'&gt; 2: Technical data of samples'</mwsh:strings>);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss2=9;
                ch2=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch2~=poss2
                    ch2=menu(<mwsh:strings xml:space="preserve">'Technical data of samples for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch2~=9
                        t = 0:1/fstr{ch2}:(length(str{ch2}) - 1)/fstr{ch2};
                        plot(t, str{ch2}), axis([0, (length(str{ch2}) - 1)/fstr{ch2} -0.4 0.5]);
                        st=sprintf(<mwsh:strings xml:space="preserve">'Plot of signal s%d.wav'</mwsh:strings>,ch2);
                        title(st);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Amplitude (normalized)'</mwsh:strings>)
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss2=9;
                ch2=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch2~=poss2
                    ch2=menu(<mwsh:strings xml:space="preserve">'Technical data of samples for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch2~=9
                        t = 0:1/fste{ch2}:(length(ste{ch2}) - 1)/fste{ch2};
                        plot(t, ste{ch2}), axis([0, (length(ste{ch2}) - 1)/fste{ch2} -0.4 0.5]);
                        st=sprintf(<mwsh:strings xml:space="preserve">'Plot of signal s%d.wav'</mwsh:strings>,ch2);
                        title(st);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Amplitude (normalized)'</mwsh:strings>)
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    t = 0:1/fs:(length(s) - 1)/fs;
                                    plot(t, s), axis([0, (length(s) - 1)/fs -0.4 0.5]);
                                    st=sprintf(<mwsh:strings xml:space="preserve">'Plot of signal %s'</mwsh:strings>,st);
                                    title(st);
                                    xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                    ylabel(<mwsh:strings xml:space="preserve">'Amplitude (normalized)'</mwsh:strings>)

                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>4</mcode-count>
   </cell>
   <cell>
      <count>5</count>
      <steptitle>3: linear and logarithmic power spectrum plot</steptitle>
      <mcode>    % After successfully running the preceding process, what is the
    % interpretation you can make of the result obtained? Compute the power
    % spectrum and plot it out using the imagesc command. Note that it is
    % better to view the power spectrum on the log scale. Locate the region in
    % the plot that contains most of the energy. Translate this location into
    % the actual ranges in time (msec) and frequency (in Hz) of the input
    % speech signal.
    %
    % As stated before, the columns matrix M3 contain the frames of the
    % original signal, filtered by the Hamming filter and transformed with the
    % FFT. The elements of M3 are complex numbers and symmetrical because FFT
    % was used to transform the data.
    % Each column in M3 is a power spectrum representation of the original signal.
    % To plot the power spectrum, we take the absolute values of the matrix
    % elements. Since the spectrum is symmetric, we only plot half of it. Note
    % that we plot simultaneously with the linear and the logarithmic spectrum
    % scale.
    %
    % The result obtained is the plot in this section.
    % In this plot, the areas containing the highest level of energy are
    % displayed in red. As we can see on the plot, the red area is located
    % between 0.3 and 0.7 seconds. The plot also shows that most of the energy
    % is concentrated in the lower frequencies (between 50 Hz and 1 kHz).

    if ch==3
        M = 100;
        N = 256;
        disp('&gt; 3: Power Spectrum Plot');
        disp('                                                      ');
        disp('&gt;Linear and Logarithmic spectrum plot');

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Linear and Logarithmic Power Spectrum Plot for : ','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        % 3 (linear)
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        t = N / 2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121);
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:t, :)).^2), axis xy;
                        title('Power Spectrum (M = 100, N = 256)');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        % 3 (logarithmic)
                        subplot(122);
                        imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                        title('Logarithmic Power Spectrum (M = 100, N = 256)');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        % D=get(gcf,'Position');
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))
                    end
                end
                close all
            end

            if ch23==2
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Linear and Logarithmic Power Spectrum Plot for : ','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        % 3 (linear)
                        frames = blockFrames(ste{ch3}, fste{ch3}, M, N);
                        t = N / 2;
                        tm = length(ste{ch3}) / fste{ch3};
                        subplot(121);
                        imagesc([0 tm], [0 fste{ch3}/2], abs(frames(1:t, :)).^2), axis xy;
                        title('Power Spectrum (M = 100, N = 256)');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        % 3 (logarithmic)
                        subplot(122);
                        imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                        title('Logarithmic Power Spectrum (M = 100, N = 256)');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        % D=get(gcf,'Position');
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))
                    end
                end
                close all;
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                st=strcat('u',num2str(an));
                                [s fs]=wavread(st);
                                frames = blockFrames(s, fs, M, N);
                                t = N / 2;
                                tm = length(s) / fs;
                                subplot(121);
                                imagesc([0 tm], [0 fs/2], abs(frames(1:t, :)).^2), axis xy;
                                title('Power Spectrum (M = 100, N = 256)');
                                xlabel('Time [s]');
                                ylabel('Frequency [Hz]');
                                colorbar;
                                %Question 3 (logarithmic)
                                subplot(122);
                                imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                                title('Logarithmic Power Spectrum (M = 100, N = 256)');
                                xlabel('Time [s]');
                                ylabel('Frequency [Hz]');
                                colorbar;

                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% After successfully running the preceding process, what is the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% interpretation you can make of the result obtained? Compute the power</mwsh:comments>
    <mwsh:comments xml:space="preserve">% spectrum and plot it out using the imagesc command. Note that it is</mwsh:comments>
    <mwsh:comments xml:space="preserve">% better to view the power spectrum on the log scale. Locate the region in</mwsh:comments>
    <mwsh:comments xml:space="preserve">% the plot that contains most of the energy. Translate this location into</mwsh:comments>
    <mwsh:comments xml:space="preserve">% the actual ranges in time (msec) and frequency (in Hz) of the input</mwsh:comments>
    <mwsh:comments xml:space="preserve">% speech signal.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% As stated before, the columns matrix M3 contain the frames of the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% original signal, filtered by the Hamming filter and transformed with the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% FFT. The elements of M3 are complex numbers and symmetrical because FFT</mwsh:comments>
    <mwsh:comments xml:space="preserve">% was used to transform the data.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Each column in M3 is a power spectrum representation of the original signal.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% To plot the power spectrum, we take the absolute values of the matrix</mwsh:comments>
    <mwsh:comments xml:space="preserve">% elements. Since the spectrum is symmetric, we only plot half of it. Note</mwsh:comments>
    <mwsh:comments xml:space="preserve">% that we plot simultaneously with the linear and the logarithmic spectrum</mwsh:comments>
    <mwsh:comments xml:space="preserve">% scale.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% The result obtained is the plot in this section.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% In this plot, the areas containing the highest level of energy are</mwsh:comments>
    <mwsh:comments xml:space="preserve">% displayed in red. As we can see on the plot, the red area is located</mwsh:comments>
    <mwsh:comments xml:space="preserve">% between 0.3 and 0.7 seconds. The plot also shows that most of the energy</mwsh:comments>
    <mwsh:comments xml:space="preserve">% is concentrated in the lower frequencies (between 50 Hz and 1 kHz).</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==3
        M = 100;
        N = 256;
        disp(<mwsh:strings xml:space="preserve">'&gt; 3: Power Spectrum Plot'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'                                                      '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'&gt;Linear and Logarithmic spectrum plot'</mwsh:strings>);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Linear and Logarithmic Power Spectrum Plot for : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        <mwsh:comments xml:space="preserve">% 3 (linear)</mwsh:comments>
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        t = N / 2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121);
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:t, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        <mwsh:comments xml:space="preserve">% 3 (logarithmic)</mwsh:comments>
                        subplot(122);
                        imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Logarithmic Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        <mwsh:comments xml:space="preserve">% D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Linear and Logarithmic Power Spectrum Plot for : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        <mwsh:comments xml:space="preserve">% 3 (linear)</mwsh:comments>
                        frames = blockFrames(ste{ch3}, fste{ch3}, M, N);
                        t = N / 2;
                        tm = length(ste{ch3}) / fste{ch3};
                        subplot(121);
                        imagesc([0 tm], [0 fste{ch3}/2], abs(frames(1:t, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        <mwsh:comments xml:space="preserve">% 3 (logarithmic)</mwsh:comments>
                        subplot(122);
                        imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Logarithmic Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        <mwsh:comments xml:space="preserve">% D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                [s fs]=wavread(st);
                                frames = blockFrames(s, fs, M, N);
                                t = N / 2;
                                tm = length(s) / fs;
                                subplot(121);
                                imagesc([0 tm], [0 fs/2], abs(frames(1:t, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                                title(<mwsh:strings xml:space="preserve">'Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                                colorbar;
                                <mwsh:comments xml:space="preserve">%Question 3 (logarithmic)</mwsh:comments>
                                subplot(122);
                                imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                                title(<mwsh:strings xml:space="preserve">'Logarithmic Power Spectrum (M = 100, N = 256)'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                                colorbar;

                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>5</mcode-count>
   </cell>
   <cell>
      <count>6</count>
      <steptitle>4: Plots for different values for N</steptitle>
      <mcode>    % Compute and plot the power spectrum of a speech file using different
    % frames sizes: for example N = 128, 256 and 512. In each case, set the
    % frame increement M to be about N/3. Can you describe and explain the
    % differences between these spectra ?
    %
    % For N = 128 we have a high resolution of time. Furthermore each frame
    % lasts a very short period of time. This result shows that the signal for
    % a frame doesn't change its nature (i.e. it will be for the same vowel or
    % consonant). On the other hand, there are only 65 distinct frequencies
    % samples. This means that we have a poor frequency resolution.
    %
    % For N = 256 we have a compro mise between the resolution in time and the
    % frequency resolution.
    % For N = 512 we have an excellent frequency resolution (256 different
    % values) but there are lesser frames, meaning that the resolution in
    % time is strongly reduced.
    % It seems that a value of 256 for N is an acceptable compromise.
    % Furthermore the number of frames is relatively small, which will reduce
    % computing time.

    if ch==4
        disp('&gt;  4: Plots for different values for M and N');
        lN = [128 256 512];

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Plots for different values of M and N for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        u=220;
                        for i = 1:length(lN)
                            N = lN(i);
                            M = round(N / 3);
                            frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                            t = N / 2;
                            tm = length(str{ch3}) / fstr{ch3};
                            temp = size(frames);
                            nbframes = temp(2);
                            u=u+1;
                            subplot(u)
                            imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                            title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));
                            xlabel('Time [s]');
                            ylabel('Frequency [Hz]');
                            colorbar
                        end
                        % D=get(gcf,'Position');
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))
                    end
                end
                close all
            end

            if ch23==2
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Plots for different values of M and N for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        u=220;
                        for i = 1:length(lN)
                            N = lN(i);
                            M = round(N / 3);
                            frames = blockFrames(ste{ch3}, fste{ch3}, M, N);
                            t = N / 2;
                            tm = length(ste{ch3}) / fste{ch3};
                            temp = size(frames);
                            nbframes = temp(2);
                            u=u+1;
                            subplot(u)
                            imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                            title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));
                            xlabel('Time [s]');
                            ylabel('Frequency [Hz]');
                            colorbar
                        end
                        % D=get(gcf,'Position');
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))
                    end
                end
                close all;
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    u=220;
                                    for i = 1:length(lN)
                                        N = lN(i);
                                        M = round(N / 3);
                                        frames = blockFrames(s, fs, M, N);
                                        t = N / 2;
                                        tm = length(s) / fs;
                                        temp = size(frames);
                                        nbframes = temp(2);
                                        u=u+1;
                                        subplot(u)
                                        imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;
                                        title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));
                                        xlabel('Time [s]');
                                        ylabel('Frequency [Hz]');
                                        colorbar
                                    end
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                     end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end
        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Compute and plot the power spectrum of a speech file using different</mwsh:comments>
    <mwsh:comments xml:space="preserve">% frames sizes: for example N = 128, 256 and 512. In each case, set the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% frame increement M to be about N/3. Can you describe and explain the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% differences between these spectra ?</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% For N = 128 we have a high resolution of time. Furthermore each frame</mwsh:comments>
    <mwsh:comments xml:space="preserve">% lasts a very short period of time. This result shows that the signal for</mwsh:comments>
    <mwsh:comments xml:space="preserve">% a frame doesn't change its nature (i.e. it will be for the same vowel or</mwsh:comments>
    <mwsh:comments xml:space="preserve">% consonant). On the other hand, there are only 65 distinct frequencies</mwsh:comments>
    <mwsh:comments xml:space="preserve">% samples. This means that we have a poor frequency resolution.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% For N = 256 we have a compro mise between the resolution in time and the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% frequency resolution.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% For N = 512 we have an excellent frequency resolution (256 different</mwsh:comments>
    <mwsh:comments xml:space="preserve">% values) but there are lesser frames, meaning that the resolution in</mwsh:comments>
    <mwsh:comments xml:space="preserve">% time is strongly reduced.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% It seems that a value of 256 for N is an acceptable compromise.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Furthermore the number of frames is relatively small, which will reduce</mwsh:comments>
    <mwsh:comments xml:space="preserve">% computing time.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==4
        disp(<mwsh:strings xml:space="preserve">'&gt;  4: Plots for different values for M and N'</mwsh:strings>);
        lN = [128 256 512];

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Plots for different values of M and N for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        u=220;
                        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:length(lN)
                            N = lN(i);
                            M = round(N / 3);
                            frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                            t = N / 2;
                            tm = length(str{ch3}) / fstr{ch3};
                            temp = size(frames);
                            nbframes = temp(2);
                            u=u+1;
                            subplot(u)
                            imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                            title(sprintf(<mwsh:strings xml:space="preserve">'Power Spectrum (M = %i, N = %i, frames = %i)'</mwsh:strings>, M, N, nbframes));
                            xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                            ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                            colorbar
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:comments xml:space="preserve">% D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Plots for different values of M and N for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        u=220;
                        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:length(lN)
                            N = lN(i);
                            M = round(N / 3);
                            frames = blockFrames(ste{ch3}, fste{ch3}, M, N);
                            t = N / 2;
                            tm = length(ste{ch3}) / fste{ch3};
                            temp = size(frames);
                            nbframes = temp(2);
                            u=u+1;
                            subplot(u)
                            imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                            title(sprintf(<mwsh:strings xml:space="preserve">'Power Spectrum (M = %i, N = %i, frames = %i)'</mwsh:strings>, M, N, nbframes));
                            xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                            ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                            colorbar
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:comments xml:space="preserve">% D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a = str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    u=220;
                                    <mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:length(lN)
                                        N = lN(i);
                                        M = round(N / 3);
                                        frames = blockFrames(s, fs, M, N);
                                        t = N / 2;
                                        tm = length(s) / fs;
                                        temp = size(frames);
                                        nbframes = temp(2);
                                        u=u+1;
                                        subplot(u)
                                        imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                                        title(sprintf(<mwsh:strings xml:space="preserve">'Power Spectrum (M = %i, N = %i, frames = %i)'</mwsh:strings>, M, N, nbframes));
                                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                                        colorbar
                                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                     <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>6</mcode-count>
   </cell>
   <cell>
      <count>7</count>
      <steptitle>5: Mel Space</steptitle>
      <mcode>    % Type 'help melfb' at the Matlab prompt for more information about this
    % function. Follow the guidelines to plot out the mel-spaced filter bank.
    % What is the behaviour of this filter bank? Compare it with the
    % theoretical part. To plot this filter bank, we use melfb command.
    % This filter bank behaves like a succession of histograms on the spectrum.
    % Each filter of the filter bank has a triangular frequency response. It
    % quantifies the zone of the frequency spectrum.
    %
    % The filter bank is used to transform the spectrum of a signal into a
    % representation which reflects more closely the behaviour of the human
    % ear. As the human ear (or the associated neurons) favours low frequencies
    % for analysing speech, the filters are denser for the lower frequencies.
    % To mimic the human ear, the filters are linearly distributed for low
    % frequencies (below 1kHz). For higher frequencies (above 1 kHz) the
    % distribution of the filters is logarithmic.
    % However we calculated 20 filters (instead of 12).

    if ch==5
        disp('&gt; 5: Mel Space');
        disp('                                                                 ');
        disp('Mel Space is function of sampling rate and since all signals ');
        disp('are recorded at same sampling rate so they have same Mel Space.');

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        plot(linspace(0, (fstr{ch3}/2), 129), (melfb(20, 256, fstr{ch3})));
                        title('Mel-Spaced Filterbank');
                        xlabel('Frequency [Hz]');
                    end
                end
                close all
            end


            if ch23==2
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        plot(linspace(0, (fste{ch3}/2), 129), (melfb(20, 256, fste{ch3})));
                        title('Mel-Spaced Filterbank');
                        xlabel('Frequency [Hz]');
                    end
                end
                close all;
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    plot(linspace(0, (fs/2), 129), (melfb(20, 256, fs)));
                                    title('Mel-Spaced Filterbank');
                                    xlabel('Frequency [Hz]');
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Type 'help melfb' at the Matlab prompt for more information about this</mwsh:comments>
    <mwsh:comments xml:space="preserve">% function. Follow the guidelines to plot out the mel-spaced filter bank.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% What is the behaviour of this filter bank? Compare it with the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% theoretical part. To plot this filter bank, we use melfb command.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% This filter bank behaves like a succession of histograms on the spectrum.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Each filter of the filter bank has a triangular frequency response. It</mwsh:comments>
    <mwsh:comments xml:space="preserve">% quantifies the zone of the frequency spectrum.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% The filter bank is used to transform the spectrum of a signal into a</mwsh:comments>
    <mwsh:comments xml:space="preserve">% representation which reflects more closely the behaviour of the human</mwsh:comments>
    <mwsh:comments xml:space="preserve">% ear. As the human ear (or the associated neurons) favours low frequencies</mwsh:comments>
    <mwsh:comments xml:space="preserve">% for analysing speech, the filters are denser for the lower frequencies.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% To mimic the human ear, the filters are linearly distributed for low</mwsh:comments>
    <mwsh:comments xml:space="preserve">% frequencies (below 1kHz). For higher frequencies (above 1 kHz) the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% distribution of the filters is logarithmic.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% However we calculated 20 filters (instead of 12).</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==5
        disp(<mwsh:strings xml:space="preserve">'&gt; 5: Mel Space'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'                                                                 '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Mel Space is function of sampling rate and since all signals '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'are recorded at same sampling rate so they have same Mel Space.'</mwsh:strings>);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Mel Space for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        plot(linspace(0, (fstr{ch3}/2), 129), (melfb(20, 256, fstr{ch3})));
                        title(<mwsh:strings xml:space="preserve">'Mel-Spaced Filterbank'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>


            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Mel Space for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        plot(linspace(0, (fste{ch3}/2), 129), (melfb(20, 256, fste{ch3})));
                        title(<mwsh:strings xml:space="preserve">'Mel-Spaced Filterbank'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    plot(linspace(0, (fs/2), 129), (melfb(20, 256, fs)));
                                    title(<mwsh:strings xml:space="preserve">'Mel-Spaced Filterbank'</mwsh:strings>);
                                    xlabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>7</mcode-count>
   </cell>
   <cell>
      <count>8</count>
      <steptitle>6: Modified spectrum</steptitle>
      <mcode>    % Compute and plot the spectrum of a speech file before and after the mel-
    % frequency wrapping step. Describe and explain the impact of the melfb
    % program.
    %
    % As we can see in the first plot, most of the information is contained in
    % the lower frequencies. This information has been extracted and amplified
    % in the second plot. The second plot therefore shows the main
    % characteristics of the speech signal.
    % Note that the transformation produced an acoustic vector of 20 dimensions.

    if ch==6
        disp('&gt; 6: Modified spectrum');
        disp('                                                              ');
        disp('Spectrum before and after Mel-Frequency wrapping');
        M = 100;
        N = 256;
        n2 = 1 + floor(N / 2);

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        m = melfb(20, N, fstr{ch3});
                        z = m * abs(frames(1:n2, :)).^2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121)
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis xy;
                        title('Power Spectrum unmodified');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        subplot(122)
                        imagesc([0 tm], [0 20], z), axis xy;
                        title('Power Spectrum modified through Mel Cepstrum filter');
                        xlabel('Time [s]');
                        ylabel('Number of Filter in Filter Bank');
                        % colorbar;D=get(gcf,'Position');
                        % set(gcf,'Position',[0 D(2) D(3)/2 D(4)])
                    end
                end
                close all
            end


            if ch23==2
                poss3=9;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                    if ch3~=9
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        m = melfb(20, N, fstr{ch3});
                        z = m * abs(frames(1:n2, :)).^2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121)
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis xy;
                        title('Power Spectrum unmodified');
                        xlabel('Time [s]');
                        ylabel('Frequency [Hz]');
                        colorbar;
                        subplot(122)
                        imagesc([0 tm], [0 20], z), axis xy;
                        title('Power Spectrum modified through Mel Cepstrum filter');
                        xlabel('Time [s]');
                        ylabel('Number of Filter in Filter Bank');
                        % colorbar;D=get(gcf,'Position');
                        % set(gcf,'Position',[0 D(2) D(3)/2 D(4)])
                    end
                end
                close all;
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    frames = blockFrames(s, fs, M, N);
                                    m = melfb(20, N, fs);
                                    z = m * abs(frames(1:n2, :)).^2;
                                    tm = length(s) / fs;
                                    subplot(121)
                                    imagesc([0 tm], [0 fs/2], abs(frames(1:n2, :)).^2), axis xy;
                                    title('Power Spectrum unmodified');
                                    xlabel('Time [s]');
                                    ylabel('Frequency [Hz]');
                                    colorbar;
                                    subplot(122)
                                    imagesc([0 tm], [0 20], z), axis xy;
                                    title('Power Spectrum modified through Mel Cepstrum filter');
                                    xlabel('Time [s]');
                                    ylabel('Number of Filter in Filter Bank');
                                    colorbar;
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Compute and plot the spectrum of a speech file before and after the mel-</mwsh:comments>
    <mwsh:comments xml:space="preserve">% frequency wrapping step. Describe and explain the impact of the melfb</mwsh:comments>
    <mwsh:comments xml:space="preserve">% program.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% As we can see in the first plot, most of the information is contained in</mwsh:comments>
    <mwsh:comments xml:space="preserve">% the lower frequencies. This information has been extracted and amplified</mwsh:comments>
    <mwsh:comments xml:space="preserve">% in the second plot. The second plot therefore shows the main</mwsh:comments>
    <mwsh:comments xml:space="preserve">% characteristics of the speech signal.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Note that the transformation produced an acoustic vector of 20 dimensions.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==6
        disp(<mwsh:strings xml:space="preserve">'&gt; 6: Modified spectrum'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'                                                              '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Spectrum before and after Mel-Frequency wrapping'</mwsh:strings>);
        M = 100;
        N = 256;
        n2 = 1 + floor(N / 2);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Mel Space for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        m = melfb(20, N, fstr{ch3});
                        z = m * abs(frames(1:n2, :)).^2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121)
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum unmodified'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        subplot(122)
                        imagesc([0 tm], [0 20], z), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum modified through Mel Cepstrum filter'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Number of Filter in Filter Bank'</mwsh:strings>);
                        <mwsh:comments xml:space="preserve">% colorbar;D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',[0 D(2) D(3)/2 D(4)])</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>


            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=9;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'Mel Space for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3~=9
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);
                        m = melfb(20, N, fstr{ch3});
                        z = m * abs(frames(1:n2, :)).^2;
                        tm = length(str{ch3}) / fstr{ch3};
                        subplot(121)
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum unmodified'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                        colorbar;
                        subplot(122)
                        imagesc([0 tm], [0 20], z), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                        title(<mwsh:strings xml:space="preserve">'Power Spectrum modified through Mel Cepstrum filter'</mwsh:strings>);
                        xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                        ylabel(<mwsh:strings xml:space="preserve">'Number of Filter in Filter Bank'</mwsh:strings>);
                        <mwsh:comments xml:space="preserve">% colorbar;D=get(gcf,'Position');</mwsh:comments>
                        <mwsh:comments xml:space="preserve">% set(gcf,'Position',[0 D(2) D(3)/2 D(4)])</mwsh:comments>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    frames = blockFrames(s, fs, M, N);
                                    m = melfb(20, N, fs);
                                    z = m * abs(frames(1:n2, :)).^2;
                                    tm = length(s) / fs;
                                    subplot(121)
                                    imagesc([0 tm], [0 fs/2], abs(frames(1:n2, :)).^2), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                                    title(<mwsh:strings xml:space="preserve">'Power Spectrum unmodified'</mwsh:strings>);
                                    xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                    ylabel(<mwsh:strings xml:space="preserve">'Frequency [Hz]'</mwsh:strings>);
                                    colorbar;
                                    subplot(122)
                                    imagesc([0 tm], [0 20], z), axis <mwsh:strings xml:space="preserve">xy</mwsh:strings>;
                                    title(<mwsh:strings xml:space="preserve">'Power Spectrum modified through Mel Cepstrum filter'</mwsh:strings>);
                                    xlabel(<mwsh:strings xml:space="preserve">'Time [s]'</mwsh:strings>);
                                    ylabel(<mwsh:strings xml:space="preserve">'Number of Filter in Filter Bank'</mwsh:strings>);
                                    colorbar;
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>8</mcode-count>
   </cell>
   <cell>
      <count>9</count>
      <steptitle>7: 2D plot of accustic vectors</steptitle>
      <mcode>    % To inspect the acoustic space (MFCC vectors) we can pick any two
    % dimensions (say the 5th and the 6th) and plot the data points in a 2D
    % plane. Use acoustic vectors of two different speakers and plot data
    % points in two different colours. Do the data regions from the two
    % speakers overlap each other? Are they in clusters?
    %
    % Mostly the two areas overlap. But certain regions seem to be used
    % exclusively by one or the other speaker. This is what will allow us to
    % distinguish the different speakers.
    % The points don't form actual clusters, but there are areas where the
    % density of points is higher.
    % Note: This is only a two dimensional plot. The actual vector
    % contains 20 dimensions.

    if ch==7
        disp('&gt;  7: 2D plot of accustic vectors');

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=3;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...
                        '2. Two Signal','3. Exit');

                    if ch3==1
                        ch31=0;
                        while ch31~=9
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                            if ch31~=9
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), 'or');
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Signal %d ',ch31);
                                legend(st);
                                title('2D plot of accoustic vectors');
                            end
                        end
                        close all;
                    end

                    if ch3==2
                        ch32=0;
                        while ch32~=8
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');
                            if ch32~=8
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), 'or');
                                hold on;
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), 'xb');
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Signal %d,',ch32);
                                st1=sprintf('Signal %d', (ch32+1) );
                                legend(st,st1);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                    end
                    close all
                end
            end

            if ch23==2
                poss3=3;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...
                        '2. Two Signal','3. Exit');

                    if ch3==1
                        ch31=0;
                        while ch31~=9
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');
                            if ch31~=9
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), 'or');
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Signal %d ',ch31);
                                legend(st);
                                title('2D plot of accoustic vectors');
                            end
                        end
                        close all;
                    end

                    if ch3==2
                        ch32=0;
                        while ch32~=8
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');

                            if ch32~=8
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), 'or');
                                hold on;
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), 'xb');
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Signal %d,',ch32);
                                st1=sprintf('Signal %d', (ch32+1) );
                                legend(st,st1);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                    end
                    close all
                end
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    c = mfcc(s, fs);
                                    plot(c(5, :), c(6, :), 'or');
                                    xlabel('5th Dimension');
                                    ylabel('6th Dimension');
                                    st1=sprintf('Signal %s.wav',st);
                                    legend(st1);
                                    title('2D plot of accoustic vectors');
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% To inspect the acoustic space (MFCC vectors) we can pick any two</mwsh:comments>
    <mwsh:comments xml:space="preserve">% dimensions (say the 5th and the 6th) and plot the data points in a 2D</mwsh:comments>
    <mwsh:comments xml:space="preserve">% plane. Use acoustic vectors of two different speakers and plot data</mwsh:comments>
    <mwsh:comments xml:space="preserve">% points in two different colours. Do the data regions from the two</mwsh:comments>
    <mwsh:comments xml:space="preserve">% speakers overlap each other? Are they in clusters?</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Mostly the two areas overlap. But certain regions seem to be used</mwsh:comments>
    <mwsh:comments xml:space="preserve">% exclusively by one or the other speaker. This is what will allow us to</mwsh:comments>
    <mwsh:comments xml:space="preserve">% distinguish the different speakers.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% The points don't form actual clusters, but there are areas where the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% density of points is higher.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Note: This is only a two dimensional plot. The actual vector</mwsh:comments>
    <mwsh:comments xml:space="preserve">% contains 20 dimensions.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==7
        disp(<mwsh:strings xml:space="preserve">'&gt;  7: 2D plot of accustic vectors'</mwsh:strings>);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=3;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors representation : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'1. One Signal'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'2. Two Signal'</mwsh:strings>,<mwsh:strings xml:space="preserve">'3. Exit'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==1
                        ch31=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch31~=9
                            ch31=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch31~=9
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), <mwsh:strings xml:space="preserve">'or'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Signal %d '</mwsh:strings>,ch31);
                                legend(st);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==2
                        ch32=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32~=8
                            ch32=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1 &amp; Signal 2'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 2 &amp; Signal 3'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3 &amp; Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 4 &amp; Signal 5'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 5 &amp; Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6 &amp; Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7 &amp; Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32~=8
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), <mwsh:strings xml:space="preserve">'or'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>;
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'xb'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Signal %d,'</mwsh:strings>,ch32);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Signal %d'</mwsh:strings>, (ch32+1) );
                                legend(st,st1);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=3;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors representation : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'1. One Signal'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'2. Two Signal'</mwsh:strings>,<mwsh:strings xml:space="preserve">'3. Exit'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==1
                        ch31=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch31~=9
                            ch31=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);
                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch31~=9
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), <mwsh:strings xml:space="preserve">'or'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Signal %d '</mwsh:strings>,ch31);
                                legend(st);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==2
                        ch32=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32~=8
                            ch32=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1 &amp; Signal 2'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 2 &amp; Signal 3'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3 &amp; Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 4 &amp; Signal 5'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 5 &amp; Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6 &amp; Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7 &amp; Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32~=8
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), <mwsh:strings xml:space="preserve">'or'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>;
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'xb'</mwsh:strings>);
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Signal %d,'</mwsh:strings>,ch32);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Signal %d'</mwsh:strings>, (ch32+1) );
                                legend(st,st1);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    c = mfcc(s, fs);
                                    plot(c(5, :), c(6, :), <mwsh:strings xml:space="preserve">'or'</mwsh:strings>);
                                    xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                    ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                    st1=sprintf(<mwsh:strings xml:space="preserve">'Signal %s.wav'</mwsh:strings>,st);
                                    legend(st1);
                                    title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>9</mcode-count>
   </cell>
   <cell>
      <count>10</count>
      <steptitle>8: Plot of the 2D trained VQ codewords</steptitle>
      <mcode>    % Plot the data points of the trained VQ codeword using the two dimensions
    % previously used for the plot of the last question.
    % The example in previous figure is an ideal case for teaching. In reality
    % however the clusters cannot be that easily distinguished. But again, this
    % is a two dimensional representation of a 20 dimensions space.

    if ch==8
        disp('&gt;  8: Plot of the 2D trained VQ codewords');

        ch23=0;
        while ch23~=4
            ch23=menu('Select Folder','Train','Test','User','Exit');

            if ch23==1
                poss3=3;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...
                        '2. Two Signal','3. Exit');

                    if ch3==1
                        ch31=0;
                        while ch31~=9
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');

                            if ch31~=9
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), 'xr')
                                hold on
                                plot(dtr{ch31}(5, :), dtr{ch31}(6, :), 'vk')
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Speaker %d',ch31);
                                st1=sprintf('Codebook %d', (ch31) );
                                legend(st,st1);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                        close all
                    end

                    if ch3==2
                        ch32=0;
                        while ch32~=8
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');

                            if ch32~=8
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), 'xr')
                                hold on
                                plot(dtr{ch32}(5, :), dtr{ch32}(6, :), 'vk')
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), 'xb')
                                plot(dtr{ch32+1}(5, :), dtr{ch32+1}(6, :), '+k')
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Speaker %d',ch32);
                                st1=sprintf('Codebook %d',ch32 );
                                st2=sprintf('Speaker %d',(ch32+1) );
                                st3=sprintf('Codebook %d', (ch32+1) );
                                legend(st,st1,st2,st3);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                    end
                    close all
                end
            end

            if ch23==2
                poss3=3;
                ch3=0;
                while ch3~=poss3
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...
                        '2. Two Signal','3. Exit');

                    if ch3==1
                        ch31=0;
                        while ch31~=9
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');

                            if ch31~=9
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), 'xr')
                                hold on
                                plot(dte{ch31}(5, :), dte{ch31}(6, :), 'vk')
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Speaker %d',ch31);
                                st1=sprintf('Codebook %d', (ch31) );
                                legend(st,st1);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                        close all
                    end

                    if ch3==2
                        ch32=0;
                        while ch32~=8
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');

                            if ch32~=8
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), 'xr')
                                hold on
                                plot(dte{ch32}(5, :), dte{ch32}(6, :), 'vk')
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), 'xb')
                                plot(dte{ch32+1}(5, :), dte{ch32+1}(6, :), '+k')
                                xlabel('5th Dimension');
                                ylabel('6th Dimension');
                                st=sprintf('Speaker %d',ch32);
                                st1=sprintf('Codebook %d',ch32 );
                                st2=sprintf('Speaker %d', (ch32+1) );
                                st3=sprintf('Codebook %d', (ch32+1) );
                                legend(st,st1,st2,st3);
                                title('2D plot of accoustic vectors');
                                hold off
                            end
                        end
                    end
                    close all
                end
            end

            if ch23==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs]=wavread(st);
                                    c = mfcc(s, fs);
                                    d = vqlbg(c, 16);
                                    plot(c(5, :), c(6, :), 'xr');
                                    hold on
                                    plot(d(5, :), d(6, :), 'vk');
                                    xlabel('5th Dimension');
                                    ylabel('6th Dimension');
                                    st1=sprintf('Speaker %s',st);
                                    st2=sprintf('Codebook %s',st);
                                    legend(st1,st2);
                                    title('2D plot of accoustic vectors');
                                    hold off
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end
                    close all;

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end

        end
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% Plot the data points of the trained VQ codeword using the two dimensions</mwsh:comments>
    <mwsh:comments xml:space="preserve">% previously used for the plot of the last question.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% The example in previous figure is an ideal case for teaching. In reality</mwsh:comments>
    <mwsh:comments xml:space="preserve">% however the clusters cannot be that easily distinguished. But again, this</mwsh:comments>
    <mwsh:comments xml:space="preserve">% is a two dimensional representation of a 20 dimensions space.</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==8
        disp(<mwsh:strings xml:space="preserve">'&gt;  8: Plot of the 2D trained VQ codewords'</mwsh:strings>);

        ch23=0;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch23~=4
            ch23=menu(<mwsh:strings xml:space="preserve">'Select Folder'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Train'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Test'</mwsh:strings>,<mwsh:strings xml:space="preserve">'User'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==1
                poss3=3;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors representation : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'1. One Signal'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'2. Two Signal'</mwsh:strings>,<mwsh:strings xml:space="preserve">'3. Exit'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==1
                        ch31=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch31~=9
                            ch31=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch31~=9
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), <mwsh:strings xml:space="preserve">'xr'</mwsh:strings>)
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
                                plot(dtr{ch31}(5, :), dtr{ch31}(6, :), <mwsh:strings xml:space="preserve">'vk'</mwsh:strings>)
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>,ch31);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>, (ch31) );
                                legend(st,st1);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==2
                        ch32=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32~=8
                            ch32=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1 &amp; Signal 2'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 2 &amp; Signal 3'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3 &amp; Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 4 &amp; Signal 5'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 5 &amp; Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6 &amp; Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7 &amp; Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32~=8
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), <mwsh:strings xml:space="preserve">'xr'</mwsh:strings>)
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
                                plot(dtr{ch32}(5, :), dtr{ch32}(6, :), <mwsh:strings xml:space="preserve">'vk'</mwsh:strings>)
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'xb'</mwsh:strings>)
                                plot(dtr{ch32+1}(5, :), dtr{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'+k'</mwsh:strings>)
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>,ch32);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>,ch32 );
                                st2=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>,(ch32+1) );
                                st3=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>, (ch32+1) );
                                legend(st,st1,st2,st3);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==2
                poss3=3;
                ch3=0;
                <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=poss3
                    ch3=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors representation : '</mwsh:strings>,<mwsh:strings xml:space="preserve">'1. One Signal'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                        <mwsh:strings xml:space="preserve">'2. Two Signal'</mwsh:strings>,<mwsh:strings xml:space="preserve">'3. Exit'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==1
                        ch31=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch31~=9
                            ch31=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 2'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 5'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch31~=9
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), <mwsh:strings xml:space="preserve">'xr'</mwsh:strings>)
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
                                plot(dte{ch31}(5, :), dte{ch31}(6, :), <mwsh:strings xml:space="preserve">'vk'</mwsh:strings>)
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>,ch31);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>, (ch31) );
                                legend(st,st1);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==2
                        ch32=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32~=8
                            ch32=menu(<mwsh:strings xml:space="preserve">'2D plot of accustic vectors for :'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 1 &amp; Signal 2'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 2 &amp; Signal 3'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 3 &amp; Signal 4'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 4 &amp; Signal 5'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                                <mwsh:strings xml:space="preserve">'Signal 5 &amp; Signal 6'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 6 &amp; Signal 7'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Signal 7 &amp; Signal 8'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32~=8
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), <mwsh:strings xml:space="preserve">'xr'</mwsh:strings>)
                                hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
                                plot(dte{ch32}(5, :), dte{ch32}(6, :), <mwsh:strings xml:space="preserve">'vk'</mwsh:strings>)
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'xb'</mwsh:strings>)
                                plot(dte{ch32+1}(5, :), dte{ch32+1}(6, :), <mwsh:strings xml:space="preserve">'+k'</mwsh:strings>)
                                xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                st=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>,ch32);
                                st1=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>,ch32 );
                                st2=sprintf(<mwsh:strings xml:space="preserve">'Speaker %d'</mwsh:strings>, (ch32+1) );
                                st3=sprintf(<mwsh:strings xml:space="preserve">'Codebook %d'</mwsh:strings>, (ch32+1) );
                                legend(st,st1,st2,st3);
                                title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch23==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs]=wavread(st);
                                    c = mfcc(s, fs);
                                    d = vqlbg(c, 16);
                                    plot(c(5, :), c(6, :), <mwsh:strings xml:space="preserve">'xr'</mwsh:strings>);
                                    hold <mwsh:strings xml:space="preserve">on</mwsh:strings>
                                    plot(d(5, :), d(6, :), <mwsh:strings xml:space="preserve">'vk'</mwsh:strings>);
                                    xlabel(<mwsh:strings xml:space="preserve">'5th Dimension'</mwsh:strings>);
                                    ylabel(<mwsh:strings xml:space="preserve">'6th Dimension'</mwsh:strings>);
                                    st1=sprintf(<mwsh:strings xml:space="preserve">'Speaker %s'</mwsh:strings>,st);
                                    st2=sprintf(<mwsh:strings xml:space="preserve">'Codebook %s'</mwsh:strings>,st);
                                    legend(st1,st2);
                                    title(<mwsh:strings xml:space="preserve">'2D plot of accoustic vectors'</mwsh:strings>);
                                    hold <mwsh:strings xml:space="preserve">off</mwsh:strings>
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>10</mcode-count>
   </cell>
   <cell>
      <count>11</count>
      <steptitle>9: Recognition rate of the computer</steptitle>
      <mcode>    % What is the recognition rate that our system can perform? Compare this
    % with the human's performances. Observe as well if the system makes errors
    % on the speech samples. If so, re -listen to the speech files and try to
    % come up with some explanations.
    % We used the following commands to test the system:
    %
    % The result is:
    % Our system was able to recognize 8 out of 8 speakers. This is an error
    % rate of 0.00%. The recognition rate of our system is much better than the
    % one of a human's recognition rate However you must be aware that this
    % test is not really representative of the computer's efficiency to
    % recognize voices because we only tested on 8 persons, with only one
    % training session and with only one word.
    %
    % Speaker 1 matches with speaker 1
    % Speaker 2 matches with speaker 2
    % Speaker 3 matches with speaker 3
    % Speaker 4 matches with speaker 4
    % Speaker 5 matches with speaker 5
    % Speaker 6 matches with speaker 6
    % Speaker 7 matches with speaker 7
    % Speaker 8 matches with speaker 8

    if ch==9
        disp('&gt; 9: Recognition rate of the computer')
        %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% What is the recognition rate that our system can perform? Compare this</mwsh:comments>
    <mwsh:comments xml:space="preserve">% with the human's performances. Observe as well if the system makes errors</mwsh:comments>
    <mwsh:comments xml:space="preserve">% on the speech samples. If so, re -listen to the speech files and try to</mwsh:comments>
    <mwsh:comments xml:space="preserve">% come up with some explanations.</mwsh:comments>
    <mwsh:comments xml:space="preserve">% We used the following commands to test the system:</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% The result is:</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Our system was able to recognize 8 out of 8 speakers. This is an error</mwsh:comments>
    <mwsh:comments xml:space="preserve">% rate of 0.00%. The recognition rate of our system is much better than the</mwsh:comments>
    <mwsh:comments xml:space="preserve">% one of a human's recognition rate However you must be aware that this</mwsh:comments>
    <mwsh:comments xml:space="preserve">% test is not really representative of the computer's efficiency to</mwsh:comments>
    <mwsh:comments xml:space="preserve">% recognize voices because we only tested on 8 persons, with only one</mwsh:comments>
    <mwsh:comments xml:space="preserve">% training session and with only one word.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 1 matches with speaker 1</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 2 matches with speaker 2</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 3 matches with speaker 3</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 4 matches with speaker 4</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 5 matches with speaker 5</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 6 matches with speaker 6</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 7 matches with speaker 7</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Speaker 8 matches with speaker 8</mwsh:comments>

    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==9
        disp(<mwsh:strings xml:space="preserve">'&gt; 9: Recognition rate of the computer'</mwsh:strings>)
        <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>11</mcode-count>
   </cell>
   <cell>
      <count>12</count>
      <steptitle>9.1 Loading from Test Folder for Comparison</steptitle>
      <text>
         <p>All 8 samples data values are loaded in file sounddatabase1.dat.</p>
      </text>
      <mcode>        for sound_number = 1: 8
            if size(ste{sound_number},2)==2
                ste{sound_number}=ste{sound_number}(:,1);
            end
            ste{sound_number} = double( ste{sound_number} );
            data{sound_number,1} = ste{sound_number};
            data{sound_number,2} = sound_number;
            st = sprintf('s%d.wav',sound_number);
            data{sound_number,3} = st;
            data{sound_number,4} = 'Test';
            fs=fste{sound_number}; %#ok&lt;NASGU&gt;
            nb=nbte{sound_number}; %#ok&lt;NASGU&gt;
            if sound_number == 1;
                save('sound_database1.dat','data','sound_number','fs','nb');
            else
                save('sound_database1.dat','data','sound_number','fs','nb','-append');
            end
        end

        disp(' ');
        disp('Sounds From TEST added to database for comparison');
        disp(' ');
        %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> sound_number = 1: 8
            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> size(ste{sound_number},2)==2
                ste{sound_number}=ste{sound_number}(:,1);
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            ste{sound_number} = double( ste{sound_number} );
            data{sound_number,1} = ste{sound_number};
            data{sound_number,2} = sound_number;
            st = sprintf(<mwsh:strings xml:space="preserve">'s%d.wav'</mwsh:strings>,sound_number);
            data{sound_number,3} = st;
            data{sound_number,4} = <mwsh:strings xml:space="preserve">'Test'</mwsh:strings>;
            fs=fste{sound_number}; <mwsh:comments xml:space="preserve">%#ok&lt;NASGU&gt;</mwsh:comments>
            nb=nbte{sound_number}; <mwsh:comments xml:space="preserve">%#ok&lt;NASGU&gt;</mwsh:comments>
            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> sound_number == 1;
                save(<mwsh:strings xml:space="preserve">'sound_database1.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'data'</mwsh:strings>,<mwsh:strings xml:space="preserve">'sound_number'</mwsh:strings>,<mwsh:strings xml:space="preserve">'fs'</mwsh:strings>,<mwsh:strings xml:space="preserve">'nb'</mwsh:strings>);
            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                save(<mwsh:strings xml:space="preserve">'sound_database1.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'data'</mwsh:strings>,<mwsh:strings xml:space="preserve">'sound_number'</mwsh:strings>,<mwsh:strings xml:space="preserve">'fs'</mwsh:strings>,<mwsh:strings xml:space="preserve">'nb'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-append'</mwsh:strings>);
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">'Sounds From TEST added to database for comparison'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
        <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>12</mcode-count>
   </cell>
   <cell>
      <count>13</count>
      <steptitle>9.2 Comparing one by one data from TRAIN FOLDER</steptitle>
      <text>
         <p>From Train folder samples are tested one by one to database stored in file sounddatabase1.dat And matching result is given on the basis of minimum distortion distance</p>
      </text>
      <mcode>        disp('Comparing one by one data from TRAIN FOLDER');
        disp(' ');
        load('sound_database1.dat','-mat');

        for classe = 1:8
            st = sprintf('Train\\S%d.wav to be compared',classe);
            disp(st);
            pause(0.5);
            if size(str{classe},2)==2
                str{classe}=str{classe}(:,1);
            end
            str{classe} = double(str{classe});
            %----- code for speaker recognition -------
            disp('MFCC cofficients computation and VQ codebook training in progress...');
            % Number of centroids required
            k =16;
            for ii=1:sound_number
                % Compute MFCC cofficients for each sound present in database
                v = mfcc(data{ii,1}, fstr{classe});
                % Train VQ codebook
                code{ii} = vqlbg(v, k);
            end
            disp('Completed.');
            disp(' ');
            % Compute MFCC coefficients for input sound
            v = mfcc(str{classe},fstr{classe});
            % Current distance and sound ID initialization
            distmin = Inf;
            k1 = 0;
            for ii=1:sound_number
                d = disteu(v, code{ii});
                dist = sum(min(d,[],2)) / size(d,1);
                if dist &lt; distmin
                    distmin = dist;
                    k1 = ii;
                end
            end
            min_index = k1;
            speech_id = data{min_index,2};
            %-----------------------------------------
            disp('Matching sound:');
            disp(' ');
            message=strcat('File:',data{min_index,3});
            disp(message);
            message=strcat('Location:',data{min_index,4});
            disp(message);
            message = strcat('Recognized speaker ID: ',num2str(speech_id));
            disp(message);
            disp(' ');
        end

        disp('                                                             ');
        pause(0.5)
        msgbox('This prototype is 100% efficient in recognising these 8 different stored sounds in TEST and TRAIN folders. ','Success','help');
    end
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">        disp(<mwsh:strings xml:space="preserve">'Comparing one by one data from TRAIN FOLDER'</mwsh:strings>);
        disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
        load(<mwsh:strings xml:space="preserve">'sound_database1.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> classe = 1:8
            st = sprintf(<mwsh:strings xml:space="preserve">'Train\\S%d.wav to be compared'</mwsh:strings>,classe);
            disp(st);
            pause(0.5);
            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> size(str{classe},2)==2
                str{classe}=str{classe}(:,1);
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            str{classe} = double(str{classe});
            <mwsh:comments xml:space="preserve">%----- code for speaker recognition -------</mwsh:comments>
            disp(<mwsh:strings xml:space="preserve">'MFCC cofficients computation and VQ codebook training in progress...'</mwsh:strings>);
            <mwsh:comments xml:space="preserve">% Number of centroids required</mwsh:comments>
            k =16;
            <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                <mwsh:comments xml:space="preserve">% Compute MFCC cofficients for each sound present in database</mwsh:comments>
                v = mfcc(data{ii,1}, fstr{classe});
                <mwsh:comments xml:space="preserve">% Train VQ codebook</mwsh:comments>
                code{ii} = vqlbg(v, k);
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            disp(<mwsh:strings xml:space="preserve">'Completed.'</mwsh:strings>);
            disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
            <mwsh:comments xml:space="preserve">% Compute MFCC coefficients for input sound</mwsh:comments>
            v = mfcc(str{classe},fstr{classe});
            <mwsh:comments xml:space="preserve">% Current distance and sound ID initialization</mwsh:comments>
            distmin = Inf;
            k1 = 0;
            <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                d = disteu(v, code{ii});
                dist = sum(min(d,[],2)) / size(d,1);
                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> dist &lt; distmin
                    distmin = dist;
                    k1 = ii;
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            min_index = k1;
            speech_id = data{min_index,2};
            <mwsh:comments xml:space="preserve">%-----------------------------------------</mwsh:comments>
            disp(<mwsh:strings xml:space="preserve">'Matching sound:'</mwsh:strings>);
            disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
            message=strcat(<mwsh:strings xml:space="preserve">'File:'</mwsh:strings>,data{min_index,3});
            disp(message);
            message=strcat(<mwsh:strings xml:space="preserve">'Location:'</mwsh:strings>,data{min_index,4});
            disp(message);
            message = strcat(<mwsh:strings xml:space="preserve">'Recognized speaker ID: '</mwsh:strings>,num2str(speech_id));
            disp(message);
            disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

        disp(<mwsh:strings xml:space="preserve">'                                                             '</mwsh:strings>);
        pause(0.5)
        msgbox(<mwsh:strings xml:space="preserve">'This prototype is 100% efficient in recognising these 8 different stored sounds in TEST and TRAIN folders. '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Success'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>13</mcode-count>
   </cell>
   <cell>
      <count>14</count>
      <steptitle>9.3 Note: Test with other speech files</steptitle>
      <mcode>    % You can also test the system with your own speech files. Use the Windows
    % program Sound Recorder to record your own voice and your friends' voices
    % Each new speaker needs to pro vide one speech file for training and one
    % for testing. Can the system recognize your voice? Enjoy.
    %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">% You can also test the system with your own speech files. Use the Windows</mwsh:comments>
    <mwsh:comments xml:space="preserve">% program Sound Recorder to record your own voice and your friends' voices</mwsh:comments>
    <mwsh:comments xml:space="preserve">% Each new speaker needs to pro vide one speech file for training and one</mwsh:comments>
    <mwsh:comments xml:space="preserve">% for testing. Can the system recognize your voice? Enjoy.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>14</mcode-count>
   </cell>
   <cell>
      <count>15</count>
      <steptitle>10: Voice Recognition by letting user enter into database and then compare</steptitle>
      <mcode>    %Voice recognition is the process of automatically recognizing who is
    %speaking on the basis of individual information included in speech waves.
    %
    %This technique makes it possible to use the speaker's voice to verify
    %their identity and control access to services such as voice dialing,
    %telephone shopping, database access services, information
    %services, voice mail, and remote access to computers.



    if ch==10
        disp('&gt; 10: Test with other speech files')
        msgbox('P.S. This prototype is for secondary security usage.','NOTE','help');
        pause(2);
        msgbox('Kindly Note this works for the stored databases only. This means that you can add sounds to the database by users and Recognition will be done for the users entered. ','NOTE','help')
        pause(2);

        chos=0;
        possibility=5;
        while chos~=possibility,
            chos=menu('Speaker Recognition System','Add a new sound from microphone',...
                'Speaker recognition from microphone',...
                'Database Info','Delete database','Exit');

            %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">    <mwsh:comments xml:space="preserve">%Voice recognition is the process of automatically recognizing who is</mwsh:comments>
    <mwsh:comments xml:space="preserve">%speaking on the basis of individual information included in speech waves.</mwsh:comments>
    <mwsh:comments xml:space="preserve">%</mwsh:comments>
    <mwsh:comments xml:space="preserve">%This technique makes it possible to use the speaker's voice to verify</mwsh:comments>
    <mwsh:comments xml:space="preserve">%their identity and control access to services such as voice dialing,</mwsh:comments>
    <mwsh:comments xml:space="preserve">%telephone shopping, database access services, information</mwsh:comments>
    <mwsh:comments xml:space="preserve">%services, voice mail, and remote access to computers.</mwsh:comments>



    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch==10
        disp(<mwsh:strings xml:space="preserve">'&gt; 10: Test with other speech files'</mwsh:strings>)
        msgbox(<mwsh:strings xml:space="preserve">'P.S. This prototype is for secondary security usage.'</mwsh:strings>,<mwsh:strings xml:space="preserve">'NOTE'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
        pause(2);
        msgbox(<mwsh:strings xml:space="preserve">'Kindly Note this works for the stored databases only. This means that you can add sounds to the database by users and Recognition will be done for the users entered. '</mwsh:strings>,<mwsh:strings xml:space="preserve">'NOTE'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>)
        pause(2);

        chos=0;
        possibility=5;
        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> chos~=possibility,
            chos=menu(<mwsh:strings xml:space="preserve">'Speaker Recognition System'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Add a new sound from microphone'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                <mwsh:strings xml:space="preserve">'Speaker recognition from microphone'</mwsh:strings>,<mwsh:keywords xml:space="preserve">...</mwsh:keywords>
                <mwsh:strings xml:space="preserve">'Database Info'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Delete database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

            <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>15</mcode-count>
   </cell>
   <cell>
      <count>16</count>
      <steptitle>10.1 Add a new sound from microphone</steptitle>
      <mcode>            if chos==1

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');
                    classe = input('Insert a class number (sound ID) that will be used for recognition:');
                    if isempty(classe)
                        classe = sound_number+1;
                        disp( num2str(classe) );
                    end
                    message=('The following parameters will be used during recording:');
                    disp(message);
                    message=strcat('Sampling frequency',num2str(samplingfrequency));
                    disp(message);
                    message=strcat('Bits per sample',num2str(samplingbits));
                    disp(message);
                    durata = input('Insert the duration of the recording (in seconds):');
                    if isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    end
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp('Now, speak into microphone...');
                    record(micrecorder,durata);

                    while (isrecording(micrecorder)==1)
                        disp('Recording...');
                        pause(0.5);
                    end
                    disp('Recording stopped.');
                    y1 = getaudiodata(micrecorder);
                    y = getaudiodata(micrecorder, 'uint8');

                    if size(y,2)==2
                        y=y(:,1);
                    end
                    y = double(y);
                    sound_number = sound_number+1;
                    data{sound_number,1} = y;
                    data{sound_number,2} = classe;
                    data{sound_number,3} = 'Microphone';
                    data{sound_number,4} = 'Microphone';
                    st=strcat('u',num2str(sound_number));
                    wavwrite(y1,samplingfrequency,samplingbits,st)
                    save('sound_database.dat','data','sound_number','-append');
                    msgbox('Sound added to database','Database result','help');
                    disp('Sound added to database');

                else
                    classe = input('Insert a class number (sound ID) that will be used for recognition:');
                    if isempty(classe)
                        classe = 1;
                        disp( num2str(classe) );
                    end
                    durata = input('Insert the duration of the recording (in seconds):');
                    if isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    end
                    samplingfrequency = input('Insert the sampling frequency (22050 recommended):');
                    if isempty(samplingfrequency )
                        samplingfrequency = 22050;
                        disp( num2str(samplingfrequency) );
                    end
                    samplingbits = input('Insert the number of bits per sample (8 recommended):');
                    if isempty(samplingbits )
                        samplingbits = 8;
                        disp( num2str(samplingbits) );
                    end
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp('Now, speak into microphone...');
                    record(micrecorder,durata);

                    while (isrecording(micrecorder)==1)
                        disp('Recording...');
                        pause(0.5);
                    end
                    disp('Recording stopped.');
                    y1 = getaudiodata(micrecorder);
                    y = getaudiodata(micrecorder, 'uint8');

                    if size(y,2)==2
                        y=y(:,1);
                    end
                    y = double(y);
                    sound_number = 1;
                    data{sound_number,1} = y;
                    data{sound_number,2} = classe;
                    data{sound_number,3} = 'Microphone';
                    data{sound_number,4} = 'Microphone';
                    st=strcat('u',num2str(sound_number));
                    wavwrite(y1,samplingfrequency,samplingbits,st)
                    save('sound_database.dat','data','sound_number','samplingfrequency','samplingbits');
                    msgbox('Sound added to database','Database result','help');
                    disp('Sound added to database');
                end
            end

            %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> chos==1

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);
                    classe = input(<mwsh:strings xml:space="preserve">'Insert a class number (sound ID) that will be used for recognition:'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(classe)
                        classe = sound_number+1;
                        disp( num2str(classe) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    message=(<mwsh:strings xml:space="preserve">'The following parameters will be used during recording:'</mwsh:strings>);
                    disp(message);
                    message=strcat(<mwsh:strings xml:space="preserve">'Sampling frequency'</mwsh:strings>,num2str(samplingfrequency));
                    disp(message);
                    message=strcat(<mwsh:strings xml:space="preserve">'Bits per sample'</mwsh:strings>,num2str(samplingbits));
                    disp(message);
                    durata = input(<mwsh:strings xml:space="preserve">'Insert the duration of the recording (in seconds):'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp(<mwsh:strings xml:space="preserve">'Now, speak into microphone...'</mwsh:strings>);
                    record(micrecorder,durata);

                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> (isrecording(micrecorder)==1)
                        disp(<mwsh:strings xml:space="preserve">'Recording...'</mwsh:strings>);
                        pause(0.5);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    disp(<mwsh:strings xml:space="preserve">'Recording stopped.'</mwsh:strings>);
                    y1 = getaudiodata(micrecorder);
                    y = getaudiodata(micrecorder, <mwsh:strings xml:space="preserve">'uint8'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> size(y,2)==2
                        y=y(:,1);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    y = double(y);
                    sound_number = sound_number+1;
                    data{sound_number,1} = y;
                    data{sound_number,2} = classe;
                    data{sound_number,3} = <mwsh:strings xml:space="preserve">'Microphone'</mwsh:strings>;
                    data{sound_number,4} = <mwsh:strings xml:space="preserve">'Microphone'</mwsh:strings>;
                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(sound_number));
                    wavwrite(y1,samplingfrequency,samplingbits,st)
                    save(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'data'</mwsh:strings>,<mwsh:strings xml:space="preserve">'sound_number'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-append'</mwsh:strings>);
                    msgbox(<mwsh:strings xml:space="preserve">'Sound added to database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database result'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
                    disp(<mwsh:strings xml:space="preserve">'Sound added to database'</mwsh:strings>);

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    classe = input(<mwsh:strings xml:space="preserve">'Insert a class number (sound ID) that will be used for recognition:'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(classe)
                        classe = 1;
                        disp( num2str(classe) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    durata = input(<mwsh:strings xml:space="preserve">'Insert the duration of the recording (in seconds):'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    samplingfrequency = input(<mwsh:strings xml:space="preserve">'Insert the sampling frequency (22050 recommended):'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(samplingfrequency )
                        samplingfrequency = 22050;
                        disp( num2str(samplingfrequency) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    samplingbits = input(<mwsh:strings xml:space="preserve">'Insert the number of bits per sample (8 recommended):'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(samplingbits )
                        samplingbits = 8;
                        disp( num2str(samplingbits) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp(<mwsh:strings xml:space="preserve">'Now, speak into microphone...'</mwsh:strings>);
                    record(micrecorder,durata);

                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> (isrecording(micrecorder)==1)
                        disp(<mwsh:strings xml:space="preserve">'Recording...'</mwsh:strings>);
                        pause(0.5);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    disp(<mwsh:strings xml:space="preserve">'Recording stopped.'</mwsh:strings>);
                    y1 = getaudiodata(micrecorder);
                    y = getaudiodata(micrecorder, <mwsh:strings xml:space="preserve">'uint8'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> size(y,2)==2
                        y=y(:,1);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    y = double(y);
                    sound_number = 1;
                    data{sound_number,1} = y;
                    data{sound_number,2} = classe;
                    data{sound_number,3} = <mwsh:strings xml:space="preserve">'Microphone'</mwsh:strings>;
                    data{sound_number,4} = <mwsh:strings xml:space="preserve">'Microphone'</mwsh:strings>;
                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(sound_number));
                    wavwrite(y1,samplingfrequency,samplingbits,st)
                    save(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'data'</mwsh:strings>,<mwsh:strings xml:space="preserve">'sound_number'</mwsh:strings>,<mwsh:strings xml:space="preserve">'samplingfrequency'</mwsh:strings>,<mwsh:strings xml:space="preserve">'samplingbits'</mwsh:strings>);
                    msgbox(<mwsh:strings xml:space="preserve">'Sound added to database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database result'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
                    disp(<mwsh:strings xml:space="preserve">'Sound added to database'</mwsh:strings>);
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

            <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>16</mcode-count>
   </cell>
   <cell>
      <count>17</count>
      <steptitle>10.2 Voice Recognition from microphone</steptitle>
      <mcode>            if chos==2

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');
                    Fs = samplingfrequency;
                    durata = input('Insert the duration of the recording (in seconds):');
                    if isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    end
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp('Now, speak into microphone...');
                    record(micrecorder,durata);

                    while (isrecording(micrecorder)==1)
                        disp('Recording...');
                        pause(0.5);
                    end
                    disp('Recording stopped.');
                    y = getaudiodata(micrecorder);
                    st='v';
                    wavwrite(y,samplingfrequency,samplingbits,st);
                    y = getaudiodata(micrecorder, 'uint8');
                    % if the input sound is not mono

                    if size(y,2)==2
                        y=y(:,1);
                    end
                    y = double(y);
                    %----- code for speaker recognition -------
                    disp('MFCC cofficients computation and VQ codebook training in progress...');
                    disp(' ');
                    % Number of centroids required
                    k =16;

                    for ii=1:sound_number
                        % Compute MFCC cofficients for each sound present in database
                        v = mfcc(data{ii,1}, Fs);
                        % Train VQ codebook
                        code{ii} = vqlbg(v, k);
                        disp('...');
                    end
                    disp('Completed.');
                    % Compute MFCC coefficients for input sound
                    v = mfcc(y,Fs);
                    % Current distance and sound ID initialization
                    distmin = Inf;
                    k1 = 0;

                    for ii=1:sound_number
                        d = disteu(v, code{ii});
                        dist = sum(min(d,[],2)) / size(d,1);
                        message=strcat('For User #',num2str(ii),' Dist : ',num2str(dist));
                        disp(message);

                        if dist &lt; distmin
                            distmin = dist;
                            k1 = ii;
                        end
                    end

                    if distmin &lt; ronaldo
                        min_index = k1;
                        speech_id = data{min_index,2};
                        %-----------------------------------------
                        disp('Matching sound:');
                        message=strcat('File:',data{min_index,3});
                        disp(message);
                        message=strcat('Location:',data{min_index,4});
                        disp(message);
                        message = strcat('Recognized speaker ID: ',num2str(speech_id));
                        disp(message);
                        msgbox(message,'Matching result','help');

                        ch3=0;
                        while ch3~=3
                            ch3=menu('Matched result verification:','Recognized Sound','Recorded sound','Exit');

                            if ch3==1
                                st=strcat('u',num2str(speech_id));
                                [s fs nb]=wavread(st);
                                p=audioplayer(s,fs,nb);
                                play(p);
                            end

                            if ch3==2
                                [s fs nb]=wavread('v');
                                p=audioplayer(s,fs,nb);
                                play(p);
                            end
                        end

                    else
                        warndlg('Wrong User . No matching Result.',' Warning ')
                    end
                else
                    warndlg('Database is empty. No matching is possible.',' Warning ')
                end
            end
            %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> chos==2

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);
                    Fs = samplingfrequency;
                    durata = input(<mwsh:strings xml:space="preserve">'Insert the duration of the recording (in seconds):'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> isempty(durata)
                        durata = 3;
                        disp( num2str(durata) );
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);
                    disp(<mwsh:strings xml:space="preserve">'Now, speak into microphone...'</mwsh:strings>);
                    record(micrecorder,durata);

                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> (isrecording(micrecorder)==1)
                        disp(<mwsh:strings xml:space="preserve">'Recording...'</mwsh:strings>);
                        pause(0.5);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    disp(<mwsh:strings xml:space="preserve">'Recording stopped.'</mwsh:strings>);
                    y = getaudiodata(micrecorder);
                    st=<mwsh:strings xml:space="preserve">'v'</mwsh:strings>;
                    wavwrite(y,samplingfrequency,samplingbits,st);
                    y = getaudiodata(micrecorder, <mwsh:strings xml:space="preserve">'uint8'</mwsh:strings>);
                    <mwsh:comments xml:space="preserve">% if the input sound is not mono</mwsh:comments>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> size(y,2)==2
                        y=y(:,1);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    y = double(y);
                    <mwsh:comments xml:space="preserve">%----- code for speaker recognition -------</mwsh:comments>
                    disp(<mwsh:strings xml:space="preserve">'MFCC cofficients computation and VQ codebook training in progress...'</mwsh:strings>);
                    disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);
                    <mwsh:comments xml:space="preserve">% Number of centroids required</mwsh:comments>
                    k =16;

                    <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                        <mwsh:comments xml:space="preserve">% Compute MFCC cofficients for each sound present in database</mwsh:comments>
                        v = mfcc(data{ii,1}, Fs);
                        <mwsh:comments xml:space="preserve">% Train VQ codebook</mwsh:comments>
                        code{ii} = vqlbg(v, k);
                        disp(<mwsh:strings xml:space="preserve">'...'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    disp(<mwsh:strings xml:space="preserve">'Completed.'</mwsh:strings>);
                    <mwsh:comments xml:space="preserve">% Compute MFCC coefficients for input sound</mwsh:comments>
                    v = mfcc(y,Fs);
                    <mwsh:comments xml:space="preserve">% Current distance and sound ID initialization</mwsh:comments>
                    distmin = Inf;
                    k1 = 0;

                    <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                        d = disteu(v, code{ii});
                        dist = sum(min(d,[],2)) / size(d,1);
                        message=strcat(<mwsh:strings xml:space="preserve">'For User #'</mwsh:strings>,num2str(ii),<mwsh:strings xml:space="preserve">' Dist : '</mwsh:strings>,num2str(dist));
                        disp(message);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> dist &lt; distmin
                            distmin = dist;
                            k1 = ii;
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> distmin &lt; ronaldo
                        min_index = k1;
                        speech_id = data{min_index,2};
                        <mwsh:comments xml:space="preserve">%-----------------------------------------</mwsh:comments>
                        disp(<mwsh:strings xml:space="preserve">'Matching sound:'</mwsh:strings>);
                        message=strcat(<mwsh:strings xml:space="preserve">'File:'</mwsh:strings>,data{min_index,3});
                        disp(message);
                        message=strcat(<mwsh:strings xml:space="preserve">'Location:'</mwsh:strings>,data{min_index,4});
                        disp(message);
                        message = strcat(<mwsh:strings xml:space="preserve">'Recognized speaker ID: '</mwsh:strings>,num2str(speech_id));
                        disp(message);
                        msgbox(message,<mwsh:strings xml:space="preserve">'Matching result'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);

                        ch3=0;
                        <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch3~=3
                            ch3=menu(<mwsh:strings xml:space="preserve">'Matched result verification:'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Recognized Sound'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Recorded sound'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==1
                                st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(speech_id));
                                [s fs nb]=wavread(st);
                                p=audioplayer(s,fs,nb);
                                play(p);
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch3==2
                                [s fs nb]=wavread(<mwsh:strings xml:space="preserve">'v'</mwsh:strings>);
                                p=audioplayer(s,fs,nb);
                                play(p);
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                        warndlg(<mwsh:strings xml:space="preserve">'Wrong User . No matching Result.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty. No matching is possible.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>17</mcode-count>
   </cell>
   <cell>
      <count>18</count>
      <steptitle>10.3 Database Info</steptitle>
      <mcode>            if chos==3

                if (exist('sound_database.dat','file')==2)
                    load('sound_database.dat','-mat');
                    message=strcat('Database has #',num2str(sound_number),'words:');
                    disp(message);
                    disp(' ');

                    for ii=1:sound_number
                        message=strcat('Location:',data{ii,3});
                        disp(message);
                        message=strcat('File:',data{ii,4});
                        disp(message);
                        message=strcat('Sound ID:',num2str(data{ii,2}));
                        disp(message);
                        disp('-');
                    end

                    ch32=0;
                    while ch32 ~=2
                        ch32=menu('Database Information','Database','Exit');

                        if ch32==1
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');
                            prompt = {st};
                            dlg_title = 'Database Information';
                            num_lines = 1;
                            def = {'1'};
                            options.Resize='on';
                            options.WindowStyle='normal';
                            options.Interpreter='tex';
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            if (isempty(an))

                            else

                                if (a &lt;= sound_number)
                                    st=strcat('u',num2str(an));
                                    [s fs nb]=wavread(st);
                                    p=audioplayer(s,fs,nb);
                                    play(p);
                                else
                                    warndlg('Invalid Word ','Warning');
                                end
                            end
                        end
                    end

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end
            %----------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> chos==3

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);
                    message=strcat(<mwsh:strings xml:space="preserve">'Database has #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words:'</mwsh:strings>);
                    disp(message);
                    disp(<mwsh:strings xml:space="preserve">' '</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                        message=strcat(<mwsh:strings xml:space="preserve">'Location:'</mwsh:strings>,data{ii,3});
                        disp(message);
                        message=strcat(<mwsh:strings xml:space="preserve">'File:'</mwsh:strings>,data{ii,4});
                        disp(message);
                        message=strcat(<mwsh:strings xml:space="preserve">'Sound ID:'</mwsh:strings>,num2str(data{ii,2}));
                        disp(message);
                        disp(<mwsh:strings xml:space="preserve">'-'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                    ch32=0;
                    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> ch32 ~=2
                        ch32=menu(<mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Exit'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> ch32==1
                            st=strcat(<mwsh:strings xml:space="preserve">'Sound Database has : #'</mwsh:strings>,num2str(sound_number),<mwsh:strings xml:space="preserve">'words. Enter a database number : #'</mwsh:strings>);
                            prompt = {st};
                            dlg_title = <mwsh:strings xml:space="preserve">'Database Information'</mwsh:strings>;
                            num_lines = 1;
                            def = {<mwsh:strings xml:space="preserve">'1'</mwsh:strings>};
                            options.Resize=<mwsh:strings xml:space="preserve">'on'</mwsh:strings>;
                            options.WindowStyle=<mwsh:strings xml:space="preserve">'normal'</mwsh:strings>;
                            options.Interpreter=<mwsh:strings xml:space="preserve">'tex'</mwsh:strings>;
                            an = inputdlg(prompt,dlg_title,num_lines,def);
                            an=cell2mat(an);
                            a=str2double(an);

                            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (isempty(an))

                            <mwsh:keywords xml:space="preserve">else</mwsh:keywords>

                                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (a &lt;= sound_number)
                                    st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(an));
                                    [s fs nb]=wavread(st);
                                    p=audioplayer(s,fs,nb);
                                    play(p);
                                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                                    warndlg(<mwsh:strings xml:space="preserve">'Invalid Word '</mwsh:strings>,<mwsh:strings xml:space="preserve">'Warning'</mwsh:strings>);
                                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:comments xml:space="preserve">%----------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>18</mcode-count>
   </cell>
   <cell>
      <count>19</count>
      <steptitle>10.4 Delete database</steptitle>
      <mcode>            if chos==4
                %clc;
                close all;

                if (exist('sound_database.dat','file')==2)
                    button = questdlg('Do you really want to remove the Database?');

                    if strcmp(button,'Yes')
                        load('sound_database.dat','-mat');

                        for ii=1:sound_number
                            st=strcat('u',num2str(ii),'.wav');
                            delete(st);
                        end

                        if (exist('v.wav','file')==2)
                            delete('v.wav');
                        end

                        delete('sound_database.dat');
                        msgbox('Database was succesfully removed from the current directory.','Database removed','help');
                    end

                else
                    warndlg('Database is empty.',' Warning ')
                end
            end
        end
    end

end
close all;
msgbox('Kindly motivate our efforts. Feel free to provide valuable feedback.','Thank You','help');
end
%--------------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve">            <mwsh:keywords xml:space="preserve">if</mwsh:keywords> chos==4
                <mwsh:comments xml:space="preserve">%clc;</mwsh:comments>
                close <mwsh:strings xml:space="preserve">all</mwsh:strings>;

                <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                    button = questdlg(<mwsh:strings xml:space="preserve">'Do you really want to remove the Database?'</mwsh:strings>);

                    <mwsh:keywords xml:space="preserve">if</mwsh:keywords> strcmp(button,<mwsh:strings xml:space="preserve">'Yes'</mwsh:strings>)
                        load(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>,<mwsh:strings xml:space="preserve">'-mat'</mwsh:strings>);

                        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> ii=1:sound_number
                            st=strcat(<mwsh:strings xml:space="preserve">'u'</mwsh:strings>,num2str(ii),<mwsh:strings xml:space="preserve">'.wav'</mwsh:strings>);
                            delete(st);
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (exist(<mwsh:strings xml:space="preserve">'v.wav'</mwsh:strings>,<mwsh:strings xml:space="preserve">'file'</mwsh:strings>)==2)
                            delete(<mwsh:strings xml:space="preserve">'v.wav'</mwsh:strings>);
                        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                        delete(<mwsh:strings xml:space="preserve">'sound_database.dat'</mwsh:strings>);
                        msgbox(<mwsh:strings xml:space="preserve">'Database was succesfully removed from the current directory.'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Database removed'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
                    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

                <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
                    warndlg(<mwsh:strings xml:space="preserve">'Database is empty.'</mwsh:strings>,<mwsh:strings xml:space="preserve">' Warning '</mwsh:strings>)
                <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>

<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
close <mwsh:strings xml:space="preserve">all</mwsh:strings>;
msgbox(<mwsh:strings xml:space="preserve">'Kindly motivate our efforts. Feel free to provide valuable feedback.'</mwsh:strings>,<mwsh:strings xml:space="preserve">'Thank You'</mwsh:strings>,<mwsh:strings xml:space="preserve">'help'</mwsh:strings>);
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:comments xml:space="preserve">%--------------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>19</mcode-count>
   </cell>
   <cell>
      <count>20</count>
      <steptitle>blockFrames Function</steptitle>
      <text>
         <p>blockFrames: Puts the signal into frames</p>
         <p>Inputs: s contains the signal to analize fs is the sampling rate of the signal m is the distance between the beginnings of two frames n is the number of samples per frame</p>
         <p>Output: M3 is a matrix containing all the frames</p>
      </text>
      <mcode>function M3 = blockFrames(s, fs, m, n)
l = length(s);
nbFrame = floor((l - n) / m) + 1;
for i = 1:n
    for j = 1:nbFrame
        M(i, j) = s(((j - 1) * m) + i); %#ok&lt;AGROW&gt;
    end
end
h = hamming(n);
M2 = diag(h) * M;
for i = 1:nbFrame
    M3(:, i) = fft(M2(:, i)); %#ok&lt;AGROW&gt;
end
end
%--------------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve"><mwsh:keywords xml:space="preserve">function</mwsh:keywords> M3 = blockFrames(s, fs, m, n)
l = length(s);
nbFrame = floor((l - n) / m) + 1;
<mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:n
    <mwsh:keywords xml:space="preserve">for</mwsh:keywords> j = 1:nbFrame
        M(i, j) = s(((j - 1) * m) + i); <mwsh:comments xml:space="preserve">%#ok&lt;AGROW&gt;</mwsh:comments>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
h = hamming(n);
M2 = diag(h) * M;
<mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:nbFrame
    M3(:, i) = fft(M2(:, i)); <mwsh:comments xml:space="preserve">%#ok&lt;AGROW&gt;</mwsh:comments>
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:comments xml:space="preserve">%--------------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>20</mcode-count>
   </cell>
   <cell>
      <count>21</count>
      <steptitle>MFCC Function</steptitle>
      <text>
         <p>MFCC</p>
         <p>Inputs: s contains the signal to analize fs is the sampling rate of the signal</p>
         <p>Output: r contains the transformed signal</p>
      </text>
      <mcode>function r = mfcc(s, fs)
m = 100;
n = 256;
frame=blockFrames(s, fs, m, n);
m = melfb(20, n, fs);
n2 = 1 + floor(n / 2);
z = m * abs(frame(1:n2, :)).^2;
r = dct(log(z));
end
%--------------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve"><mwsh:keywords xml:space="preserve">function</mwsh:keywords> r = mfcc(s, fs)
m = 100;
n = 256;
frame=blockFrames(s, fs, m, n);
m = melfb(20, n, fs);
n2 = 1 + floor(n / 2);
z = m * abs(frame(1:n2, :)).^2;
r = dct(log(z));
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:comments xml:space="preserve">%--------------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>21</mcode-count>
   </cell>
   <cell>
      <count>22</count>
      <steptitle>VQLBG Vector quantization using the Linde-Buzo-Gray algorithm</steptitle>
      <text>
         <p>VQLBG Vector quantization using the Linde-Buzo-Gray algorithm</p>
         <p>Inputs: d contains training data vectors (one per column) k is number of centroids required</p>
         <p>Output: r contains the result VQ codebook (k columns, one for each  centroids)</p>
      </text>
      <mcode>function r = vqlbg(d,k)
e = .01;
r = mean(d, 2);
dpr = 10000;
for i = 1:log2(k)
    r = [r*(1+e), r*(1-e)];
    while (1 == 1)
        z = disteu(d, r);
        [m,ind] = min(z, [], 2);
        t = 0;
        for j = 1:2^i
            r(:, j) = mean(d(:, find(ind == j)), 2); %#ok&lt;FNDSB&gt;
            x = disteu(d(:, find(ind == j)), r(:, j)); %#ok&lt;FNDSB&gt;
            for q = 1:length(x)
                t = t + x(q);
            end
        end
        if (((dpr - t)/t) &lt; e)
            break;
        else
            dpr = t;
        end
    end
end
end
%--------------------------------------------------------------------------</mcode>
      <mcode-xmlized>
         <mwsh:code xml:space="preserve"><mwsh:keywords xml:space="preserve">function</mwsh:keywords> r = vqlbg(d,k)
e = .01;
r = mean(d, 2);
dpr = 10000;
<mwsh:keywords xml:space="preserve">for</mwsh:keywords> i = 1:log2(k)
    r = [r*(1+e), r*(1-e)];
    <mwsh:keywords xml:space="preserve">while</mwsh:keywords> (1 == 1)
        z = disteu(d, r);
        [m,ind] = min(z, [], 2);
        t = 0;
        <mwsh:keywords xml:space="preserve">for</mwsh:keywords> j = 1:2^i
            r(:, j) = mean(d(:, find(ind == j)), 2); <mwsh:comments xml:space="preserve">%#ok&lt;FNDSB&gt;</mwsh:comments>
            x = disteu(d(:, find(ind == j)), r(:, j)); <mwsh:comments xml:space="preserve">%#ok&lt;FNDSB&gt;</mwsh:comments>
            <mwsh:keywords xml:space="preserve">for</mwsh:keywords> q = 1:length(x)
                t = t + x(q);
            <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
        <mwsh:keywords xml:space="preserve">if</mwsh:keywords> (((dpr - t)/t) &lt; e)
            <mwsh:keywords xml:space="preserve">break</mwsh:keywords>;
        <mwsh:keywords xml:space="preserve">else</mwsh:keywords>
            dpr = t;
        <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
    <mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:keywords xml:space="preserve">end</mwsh:keywords>
<mwsh:comments xml:space="preserve">%--------------------------------------------------------------------------</mwsh:comments></mwsh:code></mcode-xmlized>
      <mcode-count>22</mcode-count>
   </cell>
   <originalCode>%% Project: Voice Recognition and Identification system&#xD;
% By  Mahima Garg, Omar Razi, Supriya Phutela, Vaibhav Kapoor, Varun Chopra&#xD;
%--------------------------------------------------------------------------&#xD;
&#xD;
%% Main Function Voice Recognition&#xD;
function []=voicerecognition()&#xD;
% For clear screen&#xD;
clc;&#xD;
% Ronaldo is a variable used to directly set the minimum distance for&#xD;
% speech recognition.&#xD;
ronaldo=10;&#xD;
% Drogba is a variable used to directly set the maximum number of&#xD;
% users stored in database&#xD;
drogba=8;&#xD;
% st, st1, st2, st3,  will be used for filenames related purposes reducing&#xD;
% code redundancy.&#xD;
char st; char st1; char st2; char st3;&#xD;
disp('Project: Voice Recognition and Identification system');&#xD;
disp('By  Mahima Garg &amp; Omar Razi &amp; Supriya Phutela &amp; Vaibhav Kapoor &amp; Varun Chopra ');&#xD;
disp(' ');&#xD;
pause(0.5);&#xD;
disp('LOADING ');&#xD;
pause(1);&#xD;
disp('... ');&#xD;
pause(1);&#xD;
disp('... ');&#xD;
pause(1);&#xD;
disp('... ');&#xD;
pause(1);&#xD;
disp('... ');&#xD;
msgbox('We have tried to make this project as user friendly as possible. We Hope you Appreciate and Enjoy !!!','Voice Recognition and Identification System');&#xD;
&#xD;
% Preallocating array&#xD;
str = {8}; fstr = {8}; nbtr = {8};&#xD;
ste = {8}; fste = {8}; nbte = {8};&#xD;
ctr = {8}; dtr={8};&#xD;
cte = {8}; dte={8};&#xD;
data = {drogba,4};&#xD;
code = {8};&#xD;
&#xD;
for i = 1:8&#xD;
&#xD;
    % Read audio data from train folder for performing operations&#xD;
    st=strcat('train\s',num2str(i),'.wav');&#xD;
    [s1 fs1 nb1]=wavread(st);&#xD;
    str{i} = s1; fstr{i} = fs1; nbtr{i} = nb1;&#xD;
&#xD;
    % Read audio data from test folder for performing operations&#xD;
    st = strcat('test\s',num2str(i),'.wav');&#xD;
    [st1 fst1 nbt1] = wavread(st);&#xD;
    ste{i} = st1; fste{i} = fst1; nbte{i} = nbt1;&#xD;
&#xD;
    % Compute MFCC of the audio data to be used in Speech Processing for Train&#xD;
    % Folder&#xD;
    ctr{i} = mfcc(str{i},fstr{i});&#xD;
&#xD;
    % Compute MFCC of the audio data to be used in Speech Processing for Test&#xD;
    % Folder&#xD;
    cte{i} = mfcc(ste{i},fste{i});&#xD;
&#xD;
    % Compute Vector Quantization of the audio data to be used in Speech&#xD;
    % Processing for Train Folder&#xD;
    dtr{i} = vqlbg(ctr{i},16);&#xD;
&#xD;
    % Compute Vector Quantization of the audio data to be used in Speech&#xD;
    % Processing for Test Folder&#xD;
    dte{i} = vqlbg(cte{i},16);&#xD;
end&#xD;
&#xD;
% For making Choice&#xD;
ch=0;&#xD;
poss=11;&#xD;
while ch~=poss&#xD;
&#xD;
    ch=menu('Speaker Recognition System','1: Human speaker recognition',...&#xD;
        '2: Technical data of samples',...&#xD;
        '3: Power Spectrum','4: Power Spectrum with different M and N',...&#xD;
        '5: Mel-Spaced Filter Bank',...&#xD;
        '6: Spectrum before and after Mel-Frequency wrapping',...&#xD;
        '7: 2D plot of acoustic vectors',...&#xD;
        '8: Plot of VQ codewords','9: Recognition rate of the computer',...&#xD;
        '10: Test with other speech files','11: Exit');&#xD;
    disp('                                                                  ');&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%% 1: Human speaker recognition&#xD;
    % Play each sound file in the TRAIN folder. Can you distinguish the voices&#xD;
    % of those eight speakers? Now play each sound in the TEST folder in a&#xD;
    % random order without looking at the file name (pretending that you do not&#xD;
    % know the speaker) and try to identify the speaker using your knowledge of&#xD;
    % their voices that you just learned from the TRAIN folder. This is exactly&#xD;
    % what the computer will do in our system.&#xD;
    % What is your (human performance) recognition rate ?&#xD;
    % Record this result so that it can be used later to be compared with the&#xD;
    % computer's performance of our system. Both of us seem to be unable to&#xD;
    % recognise random people just by listening at their voice. Our success&#xD;
    % rates for the provided samples were 1 person out of 8 each.&#xD;
    %&#xD;
    % However, for the samples we used in question 10, we were easily able to&#xD;
    % recognise each speaker. This is probably because we knew all the persons.&#xD;
    % We also realized that we did not identify speakers by the frequencies&#xD;
    % they use to talk, but rather by other characteristics, like accent,&#xD;
    % speed, etc.&#xD;
&#xD;
    if ch==1&#xD;
        disp('&gt;  1: Human speaker recognition');&#xD;
        disp('Play each sound file in the TRAIN folder.');&#xD;
        disp('Can you distinguish the voices of those eight speakers?');&#xD;
        disp('Now play each sound in the TEST folder in a random order without looking at the file name ');&#xD;
        disp('and try to identify the speaker using your knowledge of their voices that you have just heard,');&#xD;
        disp('from the TRAIN folder. This is exactly what the computer will do in our system.');&#xD;
        disp('                                                                                                  ');&#xD;
        disp('                                                                                                   ');&#xD;
        disp('All of us seem to be unable to recognise random people just by listening to their voice. ');&#xD;
        disp('We also realize that we do not identify speakers by the frequencies with which they use to talk,  ');&#xD;
        disp('but rather by other characteristics, like accent, speed, etc.');&#xD;
        pause(1);&#xD;
&#xD;
        ch2=0;&#xD;
        while ch2~=4&#xD;
            ch2=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch2==1&#xD;
&#xD;
                ch3=0;&#xD;
                while ch3~=9&#xD;
                    ch3=menu('Train :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        p=audioplayer(str{ch3},fstr{ch3},nbtr{ch3});&#xD;
                        play(p);&#xD;
                    end&#xD;
                end&#xD;
            end&#xD;
&#xD;
            if ch2==2&#xD;
&#xD;
                ch3=0;&#xD;
                while ch3~=9&#xD;
                    ch3=menu('Test :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        p=audioplayer(ste{ch3},fste{ch3},nbte{ch3});&#xD;
                        play(p);&#xD;
                    end&#xD;
                end&#xD;
                close all;&#xD;
            end&#xD;
&#xD;
            if ch2==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a = str2double(an);&#xD;
&#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs nb]=wavread(st);&#xD;
                                    p=audioplayer(s,fs,nb);&#xD;
                                    play(p);&#xD;
&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                        close all;&#xD;
                    end&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%% 2: Technical data of samples&#xD;
    % Read a sound file into Matlab. Check it by playing the sound file in&#xD;
    % Matlab using the function: sound. What is the sampling rate? What is the&#xD;
    % highest frequency that the recorded sound can capture with fidelity? With&#xD;
    % that sampling rate, how many msecs of actual speech are contained in a&#xD;
    % block of 256 samples?&#xD;
    %&#xD;
    % Plot the signal to view it in the time domain. It should be obvious that&#xD;
    % the raw data in the time domain has a great amount of data and for this&#xD;
    % reason it is difficult to analyse the voice characteristic. So the&#xD;
    % purpose of this step (speech feature extraction) should be clear now!&#xD;
    %&#xD;
    % Intermediate steps that follows:&#xD;
    %&#xD;
    % Frames blocking phase&#xD;
    % To obtain a matrix M containing all the frames, we used the following script:&#xD;
    % That way we obtain the 256 x 129 matrix M.&#xD;
    %&#xD;
    % Windowing phase&#xD;
    % We create the Hamming matrix and transform the matrix M into the new&#xD;
    % matrix M2, where the column vectors of M2 are the original frame vectors&#xD;
    % transformed by the Hamming filter.&#xD;
    %&#xD;
    % FFT Phase&#xD;
    % We create a new matrix M3 where the column vectors are the FFTs of the&#xD;
    % column vectors of M2.&#xD;
&#xD;
    if ch==2&#xD;
        disp('&gt; 2: Technical data of samples');&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss2=9;&#xD;
                ch2=0;&#xD;
                while ch2~=poss2&#xD;
                    ch2=menu('Technical data of samples for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch2~=9&#xD;
                        t = 0:1/fstr{ch2}:(length(str{ch2}) - 1)/fstr{ch2};&#xD;
                        plot(t, str{ch2}), axis([0, (length(str{ch2}) - 1)/fstr{ch2} -0.4 0.5]);&#xD;
                        st=sprintf('Plot of signal s%d.wav',ch2);&#xD;
                        title(st);&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Amplitude (normalized)')&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
            if ch23==2&#xD;
                poss2=9;&#xD;
                ch2=0;&#xD;
                while ch2~=poss2&#xD;
                    ch2=menu('Technical data of samples for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch2~=9&#xD;
                        t = 0:1/fste{ch2}:(length(ste{ch2}) - 1)/fste{ch2};&#xD;
                        plot(t, ste{ch2}), axis([0, (length(ste{ch2}) - 1)/fste{ch2} -0.4 0.5]);&#xD;
                        st=sprintf('Plot of signal s%d.wav',ch2);&#xD;
                        title(st);&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Amplitude (normalized)')&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a = str2double(an);&#xD;
&#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    t = 0:1/fs:(length(s) - 1)/fs;&#xD;
                                    plot(t, s), axis([0, (length(s) - 1)/fs -0.4 0.5]);&#xD;
                                    st=sprintf('Plot of signal %s',st);&#xD;
                                    title(st);&#xD;
                                    xlabel('Time [s]');&#xD;
                                    ylabel('Amplitude (normalized)')&#xD;
&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%% 3: linear and logarithmic power spectrum plot&#xD;
    % After successfully running the preceding process, what is the&#xD;
    % interpretation you can make of the result obtained? Compute the power&#xD;
    % spectrum and plot it out using the imagesc command. Note that it is&#xD;
    % better to view the power spectrum on the log scale. Locate the region in&#xD;
    % the plot that contains most of the energy. Translate this location into&#xD;
    % the actual ranges in time (msec) and frequency (in Hz) of the input&#xD;
    % speech signal.&#xD;
    %&#xD;
    % As stated before, the columns matrix M3 contain the frames of the&#xD;
    % original signal, filtered by the Hamming filter and transformed with the&#xD;
    % FFT. The elements of M3 are complex numbers and symmetrical because FFT&#xD;
    % was used to transform the data.&#xD;
    % Each column in M3 is a power spectrum representation of the original signal.&#xD;
    % To plot the power spectrum, we take the absolute values of the matrix&#xD;
    % elements. Since the spectrum is symmetric, we only plot half of it. Note&#xD;
    % that we plot simultaneously with the linear and the logarithmic spectrum&#xD;
    % scale.&#xD;
    %&#xD;
    % The result obtained is the plot in this section.&#xD;
    % In this plot, the areas containing the highest level of energy are&#xD;
    % displayed in red. As we can see on the plot, the red area is located&#xD;
    % between 0.3 and 0.7 seconds. The plot also shows that most of the energy&#xD;
    % is concentrated in the lower frequencies (between 50 Hz and 1 kHz).&#xD;
&#xD;
    if ch==3&#xD;
        M = 100;&#xD;
        N = 256;&#xD;
        disp('&gt; 3: Power Spectrum Plot');&#xD;
        disp('                                                      ');&#xD;
        disp('&gt;Linear and Logarithmic spectrum plot');&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Linear and Logarithmic Power Spectrum Plot for : ','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        % 3 (linear)&#xD;
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);&#xD;
                        t = N / 2;&#xD;
                        tm = length(str{ch3}) / fstr{ch3};&#xD;
                        subplot(121);&#xD;
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:t, :)).^2), axis xy;&#xD;
                        title('Power Spectrum (M = 100, N = 256)');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        % 3 (logarithmic)&#xD;
                        subplot(122);&#xD;
                        imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                        title('Logarithmic Power Spectrum (M = 100, N = 256)');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        % D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Linear and Logarithmic Power Spectrum Plot for : ','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        % 3 (linear)&#xD;
                        frames = blockFrames(ste{ch3}, fste{ch3}, M, N);&#xD;
                        t = N / 2;&#xD;
                        tm = length(ste{ch3}) / fste{ch3};&#xD;
                        subplot(121);&#xD;
                        imagesc([0 tm], [0 fste{ch3}/2], abs(frames(1:t, :)).^2), axis xy;&#xD;
                        title('Power Spectrum (M = 100, N = 256)');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        % 3 (logarithmic)&#xD;
                        subplot(122);&#xD;
                        imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                        title('Logarithmic Power Spectrum (M = 100, N = 256)');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        % D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*2 D(4)*1.3]))&#xD;
                    end&#xD;
                end&#xD;
                close all;&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a = str2double(an);&#xD;
&#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                st=strcat('u',num2str(an));&#xD;
                                [s fs]=wavread(st);&#xD;
                                frames = blockFrames(s, fs, M, N);&#xD;
                                t = N / 2;&#xD;
                                tm = length(s) / fs;&#xD;
                                subplot(121);&#xD;
                                imagesc([0 tm], [0 fs/2], abs(frames(1:t, :)).^2), axis xy;&#xD;
                                title('Power Spectrum (M = 100, N = 256)');&#xD;
                                xlabel('Time [s]');&#xD;
                                ylabel('Frequency [Hz]');&#xD;
                                colorbar;&#xD;
                                %Question 3 (logarithmic)&#xD;
                                subplot(122);&#xD;
                                imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                                title('Logarithmic Power Spectrum (M = 100, N = 256)');&#xD;
                                xlabel('Time [s]');&#xD;
                                ylabel('Frequency [Hz]');&#xD;
                                colorbar;&#xD;
&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  4: Plots for different values for N&#xD;
    % Compute and plot the power spectrum of a speech file using different&#xD;
    % frames sizes: for example N = 128, 256 and 512. In each case, set the&#xD;
    % frame increement M to be about N/3. Can you describe and explain the&#xD;
    % differences between these spectra ?&#xD;
    %&#xD;
    % For N = 128 we have a high resolution of time. Furthermore each frame&#xD;
    % lasts a very short period of time. This result shows that the signal for&#xD;
    % a frame doesn't change its nature (i.e. it will be for the same vowel or&#xD;
    % consonant). On the other hand, there are only 65 distinct frequencies&#xD;
    % samples. This means that we have a poor frequency resolution.&#xD;
    %&#xD;
    % For N = 256 we have a compro mise between the resolution in time and the&#xD;
    % frequency resolution.&#xD;
    % For N = 512 we have an excellent frequency resolution (256 different&#xD;
    % values) but there are lesser frames, meaning that the resolution in&#xD;
    % time is strongly reduced.&#xD;
    % It seems that a value of 256 for N is an acceptable compromise.&#xD;
    % Furthermore the number of frames is relatively small, which will reduce&#xD;
    % computing time.&#xD;
&#xD;
    if ch==4&#xD;
        disp('&gt;  4: Plots for different values for M and N');&#xD;
        lN = [128 256 512];&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Plots for different values of M and N for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        u=220;&#xD;
                        for i = 1:length(lN)&#xD;
                            N = lN(i);&#xD;
                            M = round(N / 3);&#xD;
                            frames = blockFrames(str{ch3}, fstr{ch3}, M, N);&#xD;
                            t = N / 2;&#xD;
                            tm = length(str{ch3}) / fstr{ch3};&#xD;
                            temp = size(frames);&#xD;
                            nbframes = temp(2);&#xD;
                            u=u+1;&#xD;
                            subplot(u)&#xD;
                            imagesc([0 tm], [0 fstr{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                            title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));&#xD;
                            xlabel('Time [s]');&#xD;
                            ylabel('Frequency [Hz]');&#xD;
                            colorbar&#xD;
                        end&#xD;
                        % D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Plots for different values of M and N for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        u=220;&#xD;
                        for i = 1:length(lN)&#xD;
                            N = lN(i);&#xD;
                            M = round(N / 3);&#xD;
                            frames = blockFrames(ste{ch3}, fste{ch3}, M, N);&#xD;
                            t = N / 2;&#xD;
                            tm = length(ste{ch3}) / fste{ch3};&#xD;
                            temp = size(frames);&#xD;
                            nbframes = temp(2);&#xD;
                            u=u+1;&#xD;
                            subplot(u)&#xD;
                            imagesc([0 tm], [0 fste{ch3}/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                            title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));&#xD;
                            xlabel('Time [s]');&#xD;
                            ylabel('Frequency [Hz]');&#xD;
                            colorbar&#xD;
                        end&#xD;
                        % D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',round([D(1)*.5 D(2)*.5 D(3)*1.5 D(4)*1.5]))&#xD;
                    end&#xD;
                end&#xD;
                close all;&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);                                    &#xD;
                            a = str2double(an);&#xD;
&#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    u=220;&#xD;
                                    for i = 1:length(lN)&#xD;
                                        N = lN(i);&#xD;
                                        M = round(N / 3);&#xD;
                                        frames = blockFrames(s, fs, M, N);&#xD;
                                        t = N / 2;&#xD;
                                        tm = length(s) / fs;&#xD;
                                        temp = size(frames);&#xD;
                                        nbframes = temp(2);&#xD;
                                        u=u+1;&#xD;
                                        subplot(u)&#xD;
                                        imagesc([0 tm], [0 fs/2], 20 * log10(abs(frames(1:t, :)).^2)), axis xy;&#xD;
                                        title(sprintf('Power Spectrum (M = %i, N = %i, frames = %i)', M, N, nbframes));&#xD;
                                        xlabel('Time [s]');&#xD;
                                        ylabel('Frequency [Hz]');&#xD;
                                        colorbar&#xD;
                                    end&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                     end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  5: Mel Space&#xD;
    % Type 'help melfb' at the Matlab prompt for more information about this&#xD;
    % function. Follow the guidelines to plot out the mel-spaced filter bank.&#xD;
    % What is the behaviour of this filter bank? Compare it with the&#xD;
    % theoretical part. To plot this filter bank, we use melfb command.&#xD;
    % This filter bank behaves like a succession of histograms on the spectrum.&#xD;
    % Each filter of the filter bank has a triangular frequency response. It&#xD;
    % quantifies the zone of the frequency spectrum.&#xD;
    %&#xD;
    % The filter bank is used to transform the spectrum of a signal into a&#xD;
    % representation which reflects more closely the behaviour of the human&#xD;
    % ear. As the human ear (or the associated neurons) favours low frequencies&#xD;
    % for analysing speech, the filters are denser for the lower frequencies.&#xD;
    % To mimic the human ear, the filters are linearly distributed for low&#xD;
    % frequencies (below 1kHz). For higher frequencies (above 1 kHz) the&#xD;
    % distribution of the filters is logarithmic.&#xD;
    % However we calculated 20 filters (instead of 12).&#xD;
&#xD;
    if ch==5&#xD;
        disp('&gt; 5: Mel Space');&#xD;
        disp('                                                                 ');&#xD;
        disp('Mel Space is function of sampling rate and since all signals ');&#xD;
        disp('are recorded at same sampling rate so they have same Mel Space.');&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        plot(linspace(0, (fstr{ch3}/2), 129), (melfb(20, 256, fstr{ch3})));&#xD;
                        title('Mel-Spaced Filterbank');&#xD;
                        xlabel('Frequency [Hz]');&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        plot(linspace(0, (fste{ch3}/2), 129), (melfb(20, 256, fste{ch3})));&#xD;
                        title('Mel-Spaced Filterbank');&#xD;
                        xlabel('Frequency [Hz]');&#xD;
                    end&#xD;
                end&#xD;
                close all;&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a=str2double(an);&#xD;
                            &#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    plot(linspace(0, (fs/2), 129), (melfb(20, 256, fs)));&#xD;
                                    title('Mel-Spaced Filterbank');&#xD;
                                    xlabel('Frequency [Hz]');&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  6: Modified spectrum&#xD;
    % Compute and plot the spectrum of a speech file before and after the mel-&#xD;
    % frequency wrapping step. Describe and explain the impact of the melfb&#xD;
    % program.&#xD;
    %&#xD;
    % As we can see in the first plot, most of the information is contained in&#xD;
    % the lower frequencies. This information has been extracted and amplified&#xD;
    % in the second plot. The second plot therefore shows the main&#xD;
    % characteristics of the speech signal.&#xD;
    % Note that the transformation produced an acoustic vector of 20 dimensions.&#xD;
&#xD;
    if ch==6&#xD;
        disp('&gt; 6: Modified spectrum');&#xD;
        disp('                                                              ');&#xD;
        disp('Spectrum before and after Mel-Frequency wrapping');&#xD;
        M = 100;&#xD;
        N = 256;&#xD;
        n2 = 1 + floor(N / 2);&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);&#xD;
                        m = melfb(20, N, fstr{ch3});&#xD;
                        z = m * abs(frames(1:n2, :)).^2;&#xD;
                        tm = length(str{ch3}) / fstr{ch3};&#xD;
                        subplot(121)&#xD;
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis xy;&#xD;
                        title('Power Spectrum unmodified');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        subplot(122)&#xD;
                        imagesc([0 tm], [0 20], z), axis xy;&#xD;
                        title('Power Spectrum modified through Mel Cepstrum filter');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Number of Filter in Filter Bank');&#xD;
                        % colorbar;D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',[0 D(2) D(3)/2 D(4)])&#xD;
                    end&#xD;
                end&#xD;
                close all&#xD;
            end&#xD;
&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=9;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('Mel Space for :','Signal 1','Signal 2','Signal 3',...&#xD;
                        'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                    if ch3~=9&#xD;
                        frames = blockFrames(str{ch3}, fstr{ch3}, M, N);&#xD;
                        m = melfb(20, N, fstr{ch3});&#xD;
                        z = m * abs(frames(1:n2, :)).^2;&#xD;
                        tm = length(str{ch3}) / fstr{ch3};&#xD;
                        subplot(121)&#xD;
                        imagesc([0 tm], [0 fstr{ch3}/2], abs(frames(1:n2, :)).^2), axis xy;&#xD;
                        title('Power Spectrum unmodified');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Frequency [Hz]');&#xD;
                        colorbar;&#xD;
                        subplot(122)&#xD;
                        imagesc([0 tm], [0 20], z), axis xy;&#xD;
                        title('Power Spectrum modified through Mel Cepstrum filter');&#xD;
                        xlabel('Time [s]');&#xD;
                        ylabel('Number of Filter in Filter Bank');&#xD;
                        % colorbar;D=get(gcf,'Position');&#xD;
                        % set(gcf,'Position',[0 D(2) D(3)/2 D(4)])&#xD;
                    end&#xD;
                end&#xD;
                close all;&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);                         &#xD;
                            a=str2double(an);&#xD;
                            &#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    frames = blockFrames(s, fs, M, N);&#xD;
                                    m = melfb(20, N, fs);&#xD;
                                    z = m * abs(frames(1:n2, :)).^2;&#xD;
                                    tm = length(s) / fs;&#xD;
                                    subplot(121)&#xD;
                                    imagesc([0 tm], [0 fs/2], abs(frames(1:n2, :)).^2), axis xy;&#xD;
                                    title('Power Spectrum unmodified');&#xD;
                                    xlabel('Time [s]');&#xD;
                                    ylabel('Frequency [Hz]');&#xD;
                                    colorbar;&#xD;
                                    subplot(122)&#xD;
                                    imagesc([0 tm], [0 20], z), axis xy;&#xD;
                                    title('Power Spectrum modified through Mel Cepstrum filter');&#xD;
                                    xlabel('Time [s]');&#xD;
                                    ylabel('Number of Filter in Filter Bank');&#xD;
                                    colorbar;&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  7: 2D plot of accustic vectors&#xD;
    % To inspect the acoustic space (MFCC vectors) we can pick any two&#xD;
    % dimensions (say the 5th and the 6th) and plot the data points in a 2D&#xD;
    % plane. Use acoustic vectors of two different speakers and plot data&#xD;
    % points in two different colours. Do the data regions from the two&#xD;
    % speakers overlap each other? Are they in clusters?&#xD;
    %&#xD;
    % Mostly the two areas overlap. But certain regions seem to be used&#xD;
    % exclusively by one or the other speaker. This is what will allow us to&#xD;
    % distinguish the different speakers.&#xD;
    % The points don't form actual clusters, but there are areas where the&#xD;
    % density of points is higher.&#xD;
    % Note: This is only a two dimensional plot. The actual vector&#xD;
    % contains 20 dimensions.&#xD;
&#xD;
    if ch==7&#xD;
        disp('&gt;  7: 2D plot of accustic vectors');&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=3;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...&#xD;
                        '2. Two Signal','3. Exit');&#xD;
&#xD;
                    if ch3==1&#xD;
                        ch31=0;&#xD;
                        while ch31~=9&#xD;
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...&#xD;
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                            if ch31~=9&#xD;
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), 'or');&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Signal %d ',ch31);&#xD;
                                legend(st);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                            end&#xD;
                        end&#xD;
                        close all;&#xD;
                    end&#xD;
&#xD;
                    if ch3==2&#xD;
                        ch32=0;&#xD;
                        while ch32~=8&#xD;
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...&#xD;
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...&#xD;
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');&#xD;
                            if ch32~=8&#xD;
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), 'or');&#xD;
                                hold on;&#xD;
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), 'xb');&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Signal %d,',ch32);&#xD;
                                st1=sprintf('Signal %d', (ch32+1) );&#xD;
                                legend(st,st1);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all&#xD;
                end&#xD;
            end&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=3;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...&#xD;
                        '2. Two Signal','3. Exit');&#xD;
&#xD;
                    if ch3==1&#xD;
                        ch31=0;&#xD;
                        while ch31~=9&#xD;
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...&#xD;
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
                            if ch31~=9&#xD;
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), 'or');&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Signal %d ',ch31);&#xD;
                                legend(st);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                            end&#xD;
                        end&#xD;
                        close all;&#xD;
                    end&#xD;
&#xD;
                    if ch3==2&#xD;
                        ch32=0;&#xD;
                        while ch32~=8&#xD;
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...&#xD;
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...&#xD;
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');&#xD;
&#xD;
                            if ch32~=8&#xD;
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), 'or');&#xD;
                                hold on;&#xD;
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), 'xb');&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Signal %d,',ch32);&#xD;
                                st1=sprintf('Signal %d', (ch32+1) );&#xD;
                                legend(st,st1);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all&#xD;
                end&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a=str2double(an);&#xD;
                            &#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    c = mfcc(s, fs);&#xD;
                                    plot(c(5, :), c(6, :), 'or');&#xD;
                                    xlabel('5th Dimension');&#xD;
                                    ylabel('6th Dimension');&#xD;
                                    st1=sprintf('Signal %s.wav',st);&#xD;
                                    legend(st1);&#xD;
                                    title('2D plot of accoustic vectors');&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  8: Plot of the 2D trained VQ codewords&#xD;
    % Plot the data points of the trained VQ codeword using the two dimensions&#xD;
    % previously used for the plot of the last question.&#xD;
    % The example in previous figure is an ideal case for teaching. In reality&#xD;
    % however the clusters cannot be that easily distinguished. But again, this&#xD;
    % is a two dimensional representation of a 20 dimensions space.&#xD;
&#xD;
    if ch==8&#xD;
        disp('&gt;  8: Plot of the 2D trained VQ codewords');&#xD;
&#xD;
        ch23=0;&#xD;
        while ch23~=4&#xD;
            ch23=menu('Select Folder','Train','Test','User','Exit');&#xD;
&#xD;
            if ch23==1&#xD;
                poss3=3;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...&#xD;
                        '2. Two Signal','3. Exit');&#xD;
&#xD;
                    if ch3==1&#xD;
                        ch31=0;&#xD;
                        while ch31~=9&#xD;
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...&#xD;
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
&#xD;
                            if ch31~=9&#xD;
                                plot(ctr{ch31}(5, :), ctr{ch31}(6, :), 'xr')&#xD;
                                hold on&#xD;
                                plot(dtr{ch31}(5, :), dtr{ch31}(6, :), 'vk')&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Speaker %d',ch31);&#xD;
                                st1=sprintf('Codebook %d', (ch31) );&#xD;
                                legend(st,st1);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                        close all&#xD;
                    end&#xD;
&#xD;
                    if ch3==2&#xD;
                        ch32=0;&#xD;
                        while ch32~=8&#xD;
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...&#xD;
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...&#xD;
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');&#xD;
&#xD;
                            if ch32~=8&#xD;
                                plot(ctr{ch32}(5, :), ctr{ch32}(6, :), 'xr')&#xD;
                                hold on&#xD;
                                plot(dtr{ch32}(5, :), dtr{ch32}(6, :), 'vk')&#xD;
                                plot(ctr{ch32+1}(5, :), ctr{ch32+1}(6, :), 'xb')&#xD;
                                plot(dtr{ch32+1}(5, :), dtr{ch32+1}(6, :), '+k')&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Speaker %d',ch32);&#xD;
                                st1=sprintf('Codebook %d',ch32 );&#xD;
                                st2=sprintf('Speaker %d',(ch32+1) );&#xD;
                                st3=sprintf('Codebook %d', (ch32+1) );&#xD;
                                legend(st,st1,st2,st3);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all&#xD;
                end&#xD;
            end&#xD;
&#xD;
            if ch23==2&#xD;
                poss3=3;&#xD;
                ch3=0;&#xD;
                while ch3~=poss3&#xD;
                    ch3=menu('2D plot of accustic vectors representation : ','1. One Signal',...&#xD;
                        '2. Two Signal','3. Exit');&#xD;
&#xD;
                    if ch3==1&#xD;
                        ch31=0;&#xD;
                        while ch31~=9&#xD;
                            ch31=menu('2D plot of accustic vectors for :','Signal 1','Signal 2','Signal 3',...&#xD;
                                'Signal 4','Signal 5','Signal 6','Signal 7','Signal 8','Exit');&#xD;
&#xD;
                            if ch31~=9&#xD;
                                plot(cte{ch31}(5, :), cte{ch31}(6, :), 'xr')&#xD;
                                hold on&#xD;
                                plot(dte{ch31}(5, :), dte{ch31}(6, :), 'vk')&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Speaker %d',ch31);&#xD;
                                st1=sprintf('Codebook %d', (ch31) );&#xD;
                                legend(st,st1);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                        close all&#xD;
                    end&#xD;
&#xD;
                    if ch3==2&#xD;
                        ch32=0;&#xD;
                        while ch32~=8&#xD;
                            ch32=menu('2D plot of accustic vectors for :','Signal 1 &amp; Signal 2',...&#xD;
                                'Signal 2 &amp; Signal 3','Signal 3 &amp; Signal 4','Signal 4 &amp; Signal 5',...&#xD;
                                'Signal 5 &amp; Signal 6','Signal 6 &amp; Signal 7','Signal 7 &amp; Signal 8','Exit');&#xD;
&#xD;
                            if ch32~=8&#xD;
                                plot(cte{ch32}(5, :), cte{ch32}(6, :), 'xr')&#xD;
                                hold on&#xD;
                                plot(dte{ch32}(5, :), dte{ch32}(6, :), 'vk')&#xD;
                                plot(cte{ch32+1}(5, :), cte{ch32+1}(6, :), 'xb')&#xD;
                                plot(dte{ch32+1}(5, :), dte{ch32+1}(6, :), '+k')&#xD;
                                xlabel('5th Dimension');&#xD;
                                ylabel('6th Dimension');&#xD;
                                st=sprintf('Speaker %d',ch32);&#xD;
                                st1=sprintf('Codebook %d',ch32 );&#xD;
                                st2=sprintf('Speaker %d', (ch32+1) );&#xD;
                                st3=sprintf('Codebook %d', (ch32+1) );&#xD;
                                legend(st,st1,st2,st3);&#xD;
                                title('2D plot of accoustic vectors');&#xD;
                                hold off&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all&#xD;
                end&#xD;
            end&#xD;
&#xD;
            if ch23==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a=str2double(an);&#xD;
                            &#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs]=wavread(st);&#xD;
                                    c = mfcc(s, fs);&#xD;
                                    d = vqlbg(c, 16);&#xD;
                                    plot(c(5, :), c(6, :), 'xr');&#xD;
                                    hold on&#xD;
                                    plot(d(5, :), d(6, :), 'vk');&#xD;
                                    xlabel('5th Dimension');&#xD;
                                    ylabel('6th Dimension');&#xD;
                                    st1=sprintf('Speaker %s',st);&#xD;
                                    st2=sprintf('Codebook %s',st);&#xD;
                                    legend(st1,st2);&#xD;
                                    title('2D plot of accoustic vectors');&#xD;
                                    hold off&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
                    close all;&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
&#xD;
        end&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%%  9: Recognition rate of the computer&#xD;
    % What is the recognition rate that our system can perform? Compare this&#xD;
    % with the human's performances. Observe as well if the system makes errors&#xD;
    % on the speech samples. If so, re -listen to the speech files and try to&#xD;
    % come up with some explanations.&#xD;
    % We used the following commands to test the system:&#xD;
    %&#xD;
    % The result is:&#xD;
    % Our system was able to recognize 8 out of 8 speakers. This is an error&#xD;
    % rate of 0.00%. The recognition rate of our system is much better than the&#xD;
    % one of a human's recognition rate However you must be aware that this&#xD;
    % test is not really representative of the computer's efficiency to&#xD;
    % recognize voices because we only tested on 8 persons, with only one&#xD;
    % training session and with only one word.&#xD;
    %&#xD;
    % Speaker 1 matches with speaker 1&#xD;
    % Speaker 2 matches with speaker 2&#xD;
    % Speaker 3 matches with speaker 3&#xD;
    % Speaker 4 matches with speaker 4&#xD;
    % Speaker 5 matches with speaker 5&#xD;
    % Speaker 6 matches with speaker 6&#xD;
    % Speaker 7 matches with speaker 7&#xD;
    % Speaker 8 matches with speaker 8&#xD;
&#xD;
    if ch==9&#xD;
        disp('&gt; 9: Recognition rate of the computer')&#xD;
        %----------------------------------------------------------------------&#xD;
&#xD;
%% 9.1 Loading from Test Folder for Comparison&#xD;
% All 8 samples data values are loaded in file sounddatabase1.dat.&#xD;
&#xD;
        for sound_number = 1: 8&#xD;
            if size(ste{sound_number},2)==2&#xD;
                ste{sound_number}=ste{sound_number}(:,1);&#xD;
            end&#xD;
            ste{sound_number} = double( ste{sound_number} );&#xD;
            data{sound_number,1} = ste{sound_number};&#xD;
            data{sound_number,2} = sound_number;&#xD;
            st = sprintf('s%d.wav',sound_number);&#xD;
            data{sound_number,3} = st;&#xD;
            data{sound_number,4} = 'Test';&#xD;
            fs=fste{sound_number}; %#ok&lt;NASGU&gt;&#xD;
            nb=nbte{sound_number}; %#ok&lt;NASGU&gt;&#xD;
            if sound_number == 1;&#xD;
                save('sound_database1.dat','data','sound_number','fs','nb');&#xD;
            else&#xD;
                save('sound_database1.dat','data','sound_number','fs','nb','-append');&#xD;
            end&#xD;
        end&#xD;
&#xD;
        disp(' ');&#xD;
        disp('Sounds From TEST added to database for comparison');&#xD;
        disp(' ');&#xD;
        %----------------------------------------------------------------------&#xD;
&#xD;
%% 9.2 Comparing one by one data from TRAIN FOLDER&#xD;
% From Train folder samples are tested one by one to database stored in&#xD;
% file sounddatabase1.dat &#xD;
% And matching result is given on the basis of minimum distortion distance&#xD;
&#xD;
        disp('Comparing one by one data from TRAIN FOLDER');&#xD;
        disp(' ');&#xD;
        load('sound_database1.dat','-mat');&#xD;
&#xD;
        for classe = 1:8&#xD;
            st = sprintf('Train\\S%d.wav to be compared',classe);&#xD;
            disp(st);&#xD;
            pause(0.5);&#xD;
            if size(str{classe},2)==2&#xD;
                str{classe}=str{classe}(:,1);&#xD;
            end&#xD;
            str{classe} = double(str{classe});&#xD;
            %----- code for speaker recognition -------&#xD;
            disp('MFCC cofficients computation and VQ codebook training in progress...');&#xD;
            % Number of centroids required&#xD;
            k =16;&#xD;
            for ii=1:sound_number&#xD;
                % Compute MFCC cofficients for each sound present in database&#xD;
                v = mfcc(data{ii,1}, fstr{classe});&#xD;
                % Train VQ codebook&#xD;
                code{ii} = vqlbg(v, k);&#xD;
            end&#xD;
            disp('Completed.');&#xD;
            disp(' ');&#xD;
            % Compute MFCC coefficients for input sound&#xD;
            v = mfcc(str{classe},fstr{classe});&#xD;
            % Current distance and sound ID initialization&#xD;
            distmin = Inf;&#xD;
            k1 = 0;&#xD;
            for ii=1:sound_number&#xD;
                d = disteu(v, code{ii});&#xD;
                dist = sum(min(d,[],2)) / size(d,1);&#xD;
                if dist &lt; distmin&#xD;
                    distmin = dist;&#xD;
                    k1 = ii;&#xD;
                end&#xD;
            end&#xD;
            min_index = k1;&#xD;
            speech_id = data{min_index,2};&#xD;
            %-----------------------------------------&#xD;
            disp('Matching sound:');&#xD;
            disp(' ');&#xD;
            message=strcat('File:',data{min_index,3});&#xD;
            disp(message);&#xD;
            message=strcat('Location:',data{min_index,4});&#xD;
            disp(message);&#xD;
            message = strcat('Recognized speaker ID: ',num2str(speech_id));&#xD;
            disp(message);&#xD;
            disp(' ');&#xD;
        end&#xD;
&#xD;
        disp('                                                             ');&#xD;
        pause(0.5)&#xD;
        msgbox('This prototype is 100% efficient in recognising these 8 different stored sounds in TEST and TRAIN folders. ','Success','help');&#xD;
    end&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%% 9.3 Note: Test with other speech files&#xD;
    % You can also test the system with your own speech files. Use the Windows&#xD;
    % program Sound Recorder to record your own voice and your friends' voices&#xD;
    % Each new speaker needs to pro vide one speech file for training and one&#xD;
    % for testing. Can the system recognize your voice? Enjoy.&#xD;
    %----------------------------------------------------------------------&#xD;
&#xD;
%% 10: Voice Recognition by letting user enter into database and then compare&#xD;
    %Voice recognition is the process of automatically recognizing who is&#xD;
    %speaking on the basis of individual information included in speech waves.&#xD;
    %&#xD;
    %This technique makes it possible to use the speaker's voice to verify&#xD;
    %their identity and control access to services such as voice dialing,&#xD;
    %telephone shopping, database access services, information&#xD;
    %services, voice mail, and remote access to computers.&#xD;
    &#xD;
&#xD;
&#xD;
    if ch==10&#xD;
        disp('&gt; 10: Test with other speech files')&#xD;
        msgbox('P.S. This prototype is for secondary security usage.','NOTE','help');&#xD;
        pause(2);&#xD;
        msgbox('Kindly Note this works for the stored databases only. This means that you can add sounds to the database by users and Recognition will be done for the users entered. ','NOTE','help')&#xD;
        pause(2);&#xD;
&#xD;
        chos=0;&#xD;
        possibility=5;&#xD;
        while chos~=possibility,&#xD;
            chos=menu('Speaker Recognition System','Add a new sound from microphone',...&#xD;
                'Speaker recognition from microphone',...&#xD;
                'Database Info','Delete database','Exit');&#xD;
&#xD;
            %----------------------------------------------------------------------&#xD;
&#xD;
%% 10.1 Add a new sound from microphone&#xD;
&#xD;
            if chos==1&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');                   &#xD;
                    classe = input('Insert a class number (sound ID) that will be used for recognition:');&#xD;
                    if isempty(classe)&#xD;
                        classe = sound_number+1;&#xD;
                        disp( num2str(classe) );&#xD;
                    end&#xD;
                    message=('The following parameters will be used during recording:');&#xD;
                    disp(message);&#xD;
                    message=strcat('Sampling frequency',num2str(samplingfrequency));&#xD;
                    disp(message);&#xD;
                    message=strcat('Bits per sample',num2str(samplingbits));&#xD;
                    disp(message);&#xD;
                    durata = input('Insert the duration of the recording (in seconds):');&#xD;
                    if isempty(durata)&#xD;
                        durata = 3;&#xD;
                        disp( num2str(durata) );&#xD;
                    end&#xD;
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);&#xD;
                    disp('Now, speak into microphone...');&#xD;
                    record(micrecorder,durata);&#xD;
                    &#xD;
                    while (isrecording(micrecorder)==1)&#xD;
                        disp('Recording...');&#xD;
                        pause(0.5);&#xD;
                    end&#xD;
                    disp('Recording stopped.');&#xD;
                    y1 = getaudiodata(micrecorder);&#xD;
                    y = getaudiodata(micrecorder, 'uint8');&#xD;
&#xD;
                    if size(y,2)==2&#xD;
                        y=y(:,1);&#xD;
                    end&#xD;
                    y = double(y);&#xD;
                    sound_number = sound_number+1;&#xD;
                    data{sound_number,1} = y;&#xD;
                    data{sound_number,2} = classe;&#xD;
                    data{sound_number,3} = 'Microphone';&#xD;
                    data{sound_number,4} = 'Microphone';&#xD;
                    st=strcat('u',num2str(sound_number));&#xD;
                    wavwrite(y1,samplingfrequency,samplingbits,st)&#xD;
                    save('sound_database.dat','data','sound_number','-append');&#xD;
                    msgbox('Sound added to database','Database result','help');&#xD;
                    disp('Sound added to database');&#xD;
&#xD;
                else&#xD;
                    classe = input('Insert a class number (sound ID) that will be used for recognition:');&#xD;
                    if isempty(classe)&#xD;
                        classe = 1;&#xD;
                        disp( num2str(classe) );&#xD;
                    end&#xD;
                    durata = input('Insert the duration of the recording (in seconds):');&#xD;
                    if isempty(durata)&#xD;
                        durata = 3;&#xD;
                        disp( num2str(durata) );&#xD;
                    end&#xD;
                    samplingfrequency = input('Insert the sampling frequency (22050 recommended):');&#xD;
                    if isempty(samplingfrequency )&#xD;
                        samplingfrequency = 22050;&#xD;
                        disp( num2str(samplingfrequency) );&#xD;
                    end&#xD;
                    samplingbits = input('Insert the number of bits per sample (8 recommended):');&#xD;
                    if isempty(samplingbits )&#xD;
                        samplingbits = 8;&#xD;
                        disp( num2str(samplingbits) );&#xD;
                    end&#xD;
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);&#xD;
                    disp('Now, speak into microphone...');&#xD;
                    record(micrecorder,durata);&#xD;
&#xD;
                    while (isrecording(micrecorder)==1)&#xD;
                        disp('Recording...');&#xD;
                        pause(0.5);&#xD;
                    end&#xD;
                    disp('Recording stopped.');&#xD;
                    y1 = getaudiodata(micrecorder);&#xD;
                    y = getaudiodata(micrecorder, 'uint8');&#xD;
&#xD;
                    if size(y,2)==2&#xD;
                        y=y(:,1);&#xD;
                    end&#xD;
                    y = double(y);&#xD;
                    sound_number = 1;&#xD;
                    data{sound_number,1} = y;&#xD;
                    data{sound_number,2} = classe;&#xD;
                    data{sound_number,3} = 'Microphone';&#xD;
                    data{sound_number,4} = 'Microphone';&#xD;
                    st=strcat('u',num2str(sound_number));&#xD;
                    wavwrite(y1,samplingfrequency,samplingbits,st)&#xD;
                    save('sound_database.dat','data','sound_number','samplingfrequency','samplingbits');&#xD;
                    msgbox('Sound added to database','Database result','help');&#xD;
                    disp('Sound added to database');&#xD;
                end&#xD;
            end&#xD;
&#xD;
            %----------------------------------------------------------------------&#xD;
&#xD;
%% 10.2 Voice Recognition from microphone&#xD;
&#xD;
            if chos==2&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
                    Fs = samplingfrequency;&#xD;
                    durata = input('Insert the duration of the recording (in seconds):');&#xD;
                    if isempty(durata)&#xD;
                        durata = 3;&#xD;
                        disp( num2str(durata) );&#xD;
                    end&#xD;
                    micrecorder = audiorecorder(samplingfrequency,samplingbits,1);&#xD;
                    disp('Now, speak into microphone...');&#xD;
                    record(micrecorder,durata);&#xD;
&#xD;
                    while (isrecording(micrecorder)==1)&#xD;
                        disp('Recording...');&#xD;
                        pause(0.5);&#xD;
                    end&#xD;
                    disp('Recording stopped.');&#xD;
                    y = getaudiodata(micrecorder);&#xD;
                    st='v';&#xD;
                    wavwrite(y,samplingfrequency,samplingbits,st);&#xD;
                    y = getaudiodata(micrecorder, 'uint8');&#xD;
                    % if the input sound is not mono&#xD;
&#xD;
                    if size(y,2)==2&#xD;
                        y=y(:,1);&#xD;
                    end&#xD;
                    y = double(y);&#xD;
                    %----- code for speaker recognition -------&#xD;
                    disp('MFCC cofficients computation and VQ codebook training in progress...');&#xD;
                    disp(' ');&#xD;
                    % Number of centroids required&#xD;
                    k =16;&#xD;
&#xD;
                    for ii=1:sound_number&#xD;
                        % Compute MFCC cofficients for each sound present in database&#xD;
                        v = mfcc(data{ii,1}, Fs);&#xD;
                        % Train VQ codebook&#xD;
                        code{ii} = vqlbg(v, k);&#xD;
                        disp('...');&#xD;
                    end&#xD;
                    disp('Completed.');&#xD;
                    % Compute MFCC coefficients for input sound&#xD;
                    v = mfcc(y,Fs);&#xD;
                    % Current distance and sound ID initialization&#xD;
                    distmin = Inf;&#xD;
                    k1 = 0;&#xD;
&#xD;
                    for ii=1:sound_number&#xD;
                        d = disteu(v, code{ii});&#xD;
                        dist = sum(min(d,[],2)) / size(d,1);&#xD;
                        message=strcat('For User #',num2str(ii),' Dist : ',num2str(dist));&#xD;
                        disp(message);&#xD;
             &#xD;
                        if dist &lt; distmin&#xD;
                            distmin = dist;&#xD;
                            k1 = ii;&#xD;
                        end&#xD;
                    end&#xD;
&#xD;
                    if distmin &lt; ronaldo&#xD;
                        min_index = k1;&#xD;
                        speech_id = data{min_index,2};&#xD;
                        %-----------------------------------------&#xD;
                        disp('Matching sound:');&#xD;
                        message=strcat('File:',data{min_index,3});&#xD;
                        disp(message);&#xD;
                        message=strcat('Location:',data{min_index,4});&#xD;
                        disp(message);&#xD;
                        message = strcat('Recognized speaker ID: ',num2str(speech_id));&#xD;
                        disp(message);&#xD;
                        msgbox(message,'Matching result','help');&#xD;
&#xD;
                        ch3=0;&#xD;
                        while ch3~=3&#xD;
                            ch3=menu('Matched result verification:','Recognized Sound','Recorded sound','Exit');&#xD;
&#xD;
                            if ch3==1&#xD;
                                st=strcat('u',num2str(speech_id));&#xD;
                                [s fs nb]=wavread(st);&#xD;
                                p=audioplayer(s,fs,nb);&#xD;
                                play(p);&#xD;
                            end&#xD;
&#xD;
                            if ch3==2&#xD;
                                [s fs nb]=wavread('v');&#xD;
                                p=audioplayer(s,fs,nb);&#xD;
                                play(p);&#xD;
                            end&#xD;
                        end&#xD;
&#xD;
                    else&#xD;
                        warndlg('Wrong User . No matching Result.',' Warning ')&#xD;
                    end&#xD;
                else&#xD;
                    warndlg('Database is empty. No matching is possible.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
            %----------------------------------------------------------------------&#xD;
&#xD;
%% 10.3 Database Info&#xD;
&#xD;
            if chos==3&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    load('sound_database.dat','-mat');&#xD;
                    message=strcat('Database has #',num2str(sound_number),'words:');&#xD;
                    disp(message);&#xD;
                    disp(' ');&#xD;
&#xD;
                    for ii=1:sound_number&#xD;
                        message=strcat('Location:',data{ii,3});&#xD;
                        disp(message);&#xD;
                        message=strcat('File:',data{ii,4});&#xD;
                        disp(message);&#xD;
                        message=strcat('Sound ID:',num2str(data{ii,2}));&#xD;
                        disp(message);&#xD;
                        disp('-');&#xD;
                    end&#xD;
&#xD;
                    ch32=0;&#xD;
                    while ch32 ~=2&#xD;
                        ch32=menu('Database Information','Database','Exit');&#xD;
&#xD;
                        if ch32==1&#xD;
                            st=strcat('Sound Database has : #',num2str(sound_number),'words. Enter a database number : #');&#xD;
                            prompt = {st};&#xD;
                            dlg_title = 'Database Information';&#xD;
                            num_lines = 1;&#xD;
                            def = {'1'};&#xD;
                            options.Resize='on';&#xD;
                            options.WindowStyle='normal';&#xD;
                            options.Interpreter='tex';&#xD;
                            an = inputdlg(prompt,dlg_title,num_lines,def);&#xD;
                            an=cell2mat(an);&#xD;
                            a=str2double(an);&#xD;
                            &#xD;
                            if (isempty(an))&#xD;
&#xD;
                            else&#xD;
&#xD;
                                if (a &lt;= sound_number)&#xD;
                                    st=strcat('u',num2str(an));&#xD;
                                    [s fs nb]=wavread(st);&#xD;
                                    p=audioplayer(s,fs,nb);&#xD;
                                    play(p);&#xD;
                                else&#xD;
                                    warndlg('Invalid Word ','Warning');&#xD;
                                end&#xD;
                            end&#xD;
                        end&#xD;
                    end&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
            %----------------------------------------------------------------------&#xD;
&#xD;
%% 10.4 Delete database&#xD;
&#xD;
            if chos==4&#xD;
                %clc;&#xD;
                close all;&#xD;
&#xD;
                if (exist('sound_database.dat','file')==2)&#xD;
                    button = questdlg('Do you really want to remove the Database?');&#xD;
&#xD;
                    if strcmp(button,'Yes')&#xD;
                        load('sound_database.dat','-mat');&#xD;
&#xD;
                        for ii=1:sound_number&#xD;
                            st=strcat('u',num2str(ii),'.wav');&#xD;
                            delete(st);&#xD;
                        end&#xD;
&#xD;
                        if (exist('v.wav','file')==2)&#xD;
                            delete('v.wav');&#xD;
                        end&#xD;
&#xD;
                        delete('sound_database.dat');&#xD;
                        msgbox('Database was succesfully removed from the current directory.','Database removed','help');&#xD;
                    end&#xD;
&#xD;
                else&#xD;
                    warndlg('Database is empty.',' Warning ')&#xD;
                end&#xD;
            end&#xD;
        end&#xD;
    end&#xD;
&#xD;
end&#xD;
close all;&#xD;
msgbox('Kindly motivate our efforts. Feel free to provide valuable feedback.','Thank You','help');&#xD;
end&#xD;
%--------------------------------------------------------------------------&#xD;
&#xD;
%% blockFrames Function&#xD;
% blockFrames: Puts the signal into frames&#xD;
%&#xD;
% Inputs: s contains the signal to analize&#xD;
% fs is the sampling rate of the signal&#xD;
% m is the distance between the beginnings of two frames&#xD;
% n is the number of samples per frame&#xD;
%&#xD;
% Output: M3 is a matrix containing all the frames&#xD;
&#xD;
function M3 = blockFrames(s, fs, m, n)&#xD;
l = length(s);&#xD;
nbFrame = floor((l - n) / m) + 1;&#xD;
for i = 1:n&#xD;
    for j = 1:nbFrame&#xD;
        M(i, j) = s(((j - 1) * m) + i); %#ok&lt;AGROW&gt;&#xD;
    end&#xD;
end&#xD;
h = hamming(n);&#xD;
M2 = diag(h) * M;&#xD;
for i = 1:nbFrame&#xD;
    M3(:, i) = fft(M2(:, i)); %#ok&lt;AGROW&gt;&#xD;
end&#xD;
end&#xD;
%--------------------------------------------------------------------------&#xD;
&#xD;
%% MFCC Function&#xD;
% MFCC&#xD;
%&#xD;
% Inputs: s contains the signal to analize&#xD;
% fs is the sampling rate of the signal&#xD;
%&#xD;
% Output: r contains the transformed signal&#xD;
&#xD;
function r = mfcc(s, fs)&#xD;
m = 100;&#xD;
n = 256;&#xD;
frame=blockFrames(s, fs, m, n);&#xD;
m = melfb(20, n, fs);&#xD;
n2 = 1 + floor(n / 2);&#xD;
z = m * abs(frame(1:n2, :)).^2;&#xD;
r = dct(log(z));&#xD;
end&#xD;
%--------------------------------------------------------------------------&#xD;
&#xD;
%% VQLBG Vector quantization using the Linde-Buzo-Gray algorithm&#xD;
% VQLBG Vector quantization using the Linde-Buzo-Gray algorithm&#xD;
%&#xD;
% Inputs: d contains training data vectors (one per column)&#xD;
% k is number of centroids required&#xD;
%&#xD;
% Output: r contains the result VQ codebook (k columns, one for each  centroids)&#xD;
&#xD;
function r = vqlbg(d,k)&#xD;
e = .01;&#xD;
r = mean(d, 2);&#xD;
dpr = 10000;&#xD;
for i = 1:log2(k)&#xD;
    r = [r*(1+e), r*(1-e)];&#xD;
    while (1 == 1)&#xD;
        z = disteu(d, r);&#xD;
        [m,ind] = min(z, [], 2);&#xD;
        t = 0;&#xD;
        for j = 1:2^i&#xD;
            r(:, j) = mean(d(:, find(ind == j)), 2); %#ok&lt;FNDSB&gt;&#xD;
            x = disteu(d(:, find(ind == j)), r(:, j)); %#ok&lt;FNDSB&gt;&#xD;
            for q = 1:length(x)&#xD;
                t = t + x(q);&#xD;
            end&#xD;
        end&#xD;
        if (((dpr - t)/t) &lt; e)&#xD;
            break;&#xD;
        else&#xD;
            dpr = t;&#xD;
        end&#xD;
    end&#xD;
end&#xD;
end&#xD;
%--------------------------------------------------------------------------</originalCode>
   <m-file>voicerecognition</m-file>
   <filename>C:\Users\Owner\Desktop\Usables\Voice Recognition and Identification System\voicerecognition.m</filename>
   <outputdir>C:\Users\Owner\Desktop\Usables\Voice Recognition and Identification System\html</outputdir>
</mscript>